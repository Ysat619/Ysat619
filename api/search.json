[{"id":"cf81b77854f2dfe44d1ede9201191a9c","title":"英语语法 - 笔记(updating)","content":"\n\n速查表常见缩写\n\n\nAbbreviation\nOriginal\nAbbreviation\nOriginal\n\n\n\naren’t\nare not\ncan’t\ncannot\n\n\nhadn’t\nhad not\nwasn’t\nwas not\n\n\nshouldn’t\nShould not\nisn’t\nis not\n\n\ndoesn’t\ndoes not\ndon’t\ndo not\n\n\nmustn’t\nMust not\nweren’t\nWere not\n\n\nwouldn’t\nwould not\ndidn’t\ndid not\n\n\nI’m\nI am\nYou’re\nYou are\n\n\nHe/She/It’s\nHe/She/It is\nWe’re\nWe are\n\n\nYou’re\nYou are\nThey’re\nThey are\n\n\nShan’t\nShall not\nWon’t\nwill not\n\n\n不规则动词动词时态\n\n\n状态/时间\n过去的过去\n过去\n过去的将来\n现在\n将来\n\n\n\n一般\n\ndid一般过去时\nwould do一般过去将来时\ndo一般现在时\nwill do一般将来时\n\n\n进行\n\nwas/were doing过去进行时\nwould be doing过去将来进行时\nam/is/are doing现在进行时\nwill be doing将来进行时\n\n\n进行\nhad been doing过去完成进行时\nhave been doing现在完成进行时\nwould have been doing过去将来完成进行时\n\nwill have been doing将来完成进行时\n\n\n完成\nhad done过去完成时\nhave/has done现在完成时\nwould have done过去将来完成时\n\nwill have done将来完成时\n\n\n语法体系总览\n数词（num.）基数词个位数（0-9）\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\nzero\none\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\n\n\n十到十九（10-19）\n\n\n十\n十一\n十二\n十三\n十四\n\n\n\nten\neleven\ntwelve\nthirteen\nfourteen\n\n\n十五\n十六\n十七\n十八\n十九\n\n\nfifteen\nsixteen\nseventeen\neighteen\nnineteen\n\n\n十位数，二十到九十（20-90）\n\n\n二十\n三十\n四十\n五十\n\n\n\ntwenty\nthirty\nforty\nfifty\n\n\n六十\n七十\n八十\n九十\n\n\nsixty\nseventy\neighty\nninety\n\n\n二十以上，几十几（21-99）例如：二十一 =&gt; twenty one九十九 =&gt; ninety nine十位用几十，个位用个位\n数字表达规律\n从右往左，每三位一个逗号，倒数第一个逗号之前是thousand，倒数第二个逗号之前是million，倒数第三个逗号之前是billion，倒数第四个逗号之前是trillion\n逗号之间的百位和十位都要加and，数字隔0要加and\n\n一百到九百九十九（100-999）:一百（100）=&gt; one hundred一百零一（101）=&gt; one hundred and one九百九十九（999）=&gt; nine hundred and ninety-nine\n一千到九千九千九百九十九（1000-9999）:一千（1,000） =&gt; one thousand一千零一（1,001） =&gt; one thousand and one一千零二十（1,020） =&gt; one thousand and twenty九千九百九十九（9,999） =&gt; nine thousand nine hundred and ninety-nine\n一万到一万零九百九十九（10000-10999）:一万（10,000）=&gt; ten thousand一万零一（10,001）=&gt; ten thousand and one一万零二十（10,020）=&gt; ten thousand and twenty一万零两百（10200）=&gt; ten thousand and two hundred一万零九百九十九（10,999）=&gt; ten thousand nine hundred and ninety-nine\n一万一千到九万九千九百九十九（11,000-99,999）:一万一千（11*1000=11,000）=&gt; eleven thousand一万一千零一（11,001）=&gt; eleven thousand and one一万一千零二十（11020）=&gt; eleven thousand and twenty一万一千零二百（11200）=&gt; eleven thousand two hundred九万九千九百九十九（99999）=&gt; ninety nine thousand nine hundred and ninety-nine\n十万到九十九万九千九百九十九（100000-999999）:十万（100,000）=&gt; one hundred thousand十万零一（100,001）=&gt; one hundred thousand and one十万零二十（100,020）=&gt; one hundred thousand十万零二百（100,200）=&gt; one hundred thousand and two hundred十万零二千零一（102,001）=&gt; one hundred thousang and two thousand and one九十九万九千九百九十九（999,999）=&gt; nine hundred and ninety-nine thousand nine hundred and ninety-nine\n一百万到九千九百九十九万九千九百九十九（1,000,000-99,999,999）:一百万（1,000,000）=&gt; one million一百万零一（1,000,001）=&gt; one million and one一百万零一千（1,001,000）=&gt; one million and one thousand一百零一万（1,010,000）=&gt; one million and ten thousand九千九百九十九万九千九百九十九（99,999,999）Ninety-nine million nine hundred and ninety-nine thousand and ninety-nine\n一亿到十亿以及更多（100,000,000-1,000,000,000-∞）:一亿（100,000,000）=&gt; one hundred million一亿零一（100,000,001）=&gt; one hundred million and one一亿零一千（100,001,000）=&gt; one hundred million and one thousand一亿零一百万（101,000,000）=&gt;one hundred and one million十亿（1,000,000,000）=&gt; one billion三百一十亿零二千九百万零八百八十八（31,020,900,888） =&gt; thirty-one billion and twenty million nine hundred thousand and eighty-eight\n使用特点\n作数词时候，前面可以加数词，后面不能加s，比如：two thousand(✅)，three thousands(❌)\n如果数词用作名词时候，意思是好几…的时候，前面可以加some/many/several这种词或者加数词，后面可以加of。例如：hundreds of（好几百），five hundreds of（五百左右），many millions of（数百万）\n表示年龄 =&gt; I’m twenty（我20岁）\n表示编号 =&gt; Room 101 = Room one 0 one\n表示年代 =&gt; 1940’s = nineteen forty’s(20世纪40年代)\n表示年份\n2008 = two thousand and eight\n1949 = nineteen forty-nine\n2019.9.10 = Sep.10th, 2019 = September , tenth, twenty nineteen\n\n\n\n序数词第几（第零到第九）\n\n\n第零\n第一\n第二\n第三\n第四\n第五\n第六\n第七\n第八\n第九\n\n\n\nzeroth\nfirst\nsecond\nthird\nfourth\nfifth\nsixth\nseventh\neighth\nninth\n\n\n第十到第十九\n\n\n第十\n第十一\n第十二\n第十三\n第十四\n\n\n\ntenth\neleventh\ntwelfth\nthirtheeth\nfourteenth\n\n\n第十五\n第十六\n第十七\n第十八\n第十九\n\n\nfifteenth\nsixteenth\nseventeenth\neighteenth\nnineteenth\n\n\n第几十（第二十到第九十）\n\n\n第二十\n第三十\n第四十\n第五十\n\n\n\ntwentieth\nthirhieth\nfortieth\nfiftieth\n\n\n第六十\n第七十\n第八十\n第九十\n\n\nsixieth\nseventieth\neightieth\nninetieth\n\n\n把基数词结尾的y变成i再加eth\n第二十以上，第几十几十位用基数词，个位用序数词第二十一 =&gt; twenty first第九十九 =&gt; ninety ninth\n第一百以上第整数的后面加th，如果不是整数，保留基数词只变个位数\n\n\n\n第一百\n第一千\n第一百万\n第十亿\n\n\n\none hundredth\none thousandth\none millionth\none billionth\n\n\n使用特点\n使用序数词时，一般前面要加定冠词the\nI’m in the second room(我在第二个房间)\n\n\n表示时间日期\nThe first of September=Sep 1st(九月一日)\n\n\n表示楼层\nThe first floor(一楼)\n\n\n表示几分之几，分子大于一，分母有复数形式\none third = 1 / 3\ntwo thirds = 2 / 3\n\n\n序数词前面加a/an表示再一，序数词前面加the表示顺序\nWe read the book a third times(我们读了三遍这本书)\nThe second door of the room is closed（房间的第二扇门是关的）\n\n\n\n冠词（art.）\n1. 定冠词表示这个，特指某个名词，后面跟单数/复数名词，不可数名词例如：\n\n表示上文提过的人和物-This car is popular, but the car isn’t cheap\n表示地理位置用-We are based in the Beijing\n表示江河湖海用-The Yellow River\n唯一存在的事物用-The earth\n最高级前用-This is the best cup of coffee\n表示强调时候用-Beijing is the capital of China\n乐器（西洋古典乐器）之前用\nI like to play the piano\n\n\n在形容词前用 the，会将形容词变成名词\nThe rich should help the poor.\n\n\n固定表达\nall the time 一直；总是\nby the way 顺便\nout of the question 不可能；没门\n\n\n\n2. 不定冠词泛指人和物，表示一个，后面加单数可数名词辅音发音前面加a，元音发音前面加an\n\n第一次提到的人和物-It’s a cat\n如果是对唯一事物具体情况说明-Their dream is to go on a world tour(他们的梦想是去全世界巡回演出)\n和名词连用作表语或者同位语，代表职业-I am an engineer\n表示价格/速度/频率 - 80miles an hour\n固定短语会用 - have a good time\n\n3. 零冠词有情况下可以不需要加任何冠词\n\n很广泛的概念\n复数泛指\nComputers have changed our way of life.\nWater is important.\nWe breathe air.\n\n\n书名/人名\n某些城市/国家\n某些山河湖海洲\n星球\n语言/球类/学科/棋牌\nI want to play football.\n\n\n三餐/日期/季节（一般不加冠词，如果要特指可以加the）\nSummer is hot. Winter is cold.\non Monday\n\n\n固定表达\nfrom time to time 不时地\nface to face 面对面地\nout of question 毫无疑问\n\n\n\n名词（n.）名词分类专有名词、普通名词专有名词（大多数不可数）：人名、地名、国家、组织、单位、大型活动、著名事件（首字母大写，如果缩写全部字母大写）普通名词：专有名词以外的名词\n可数名词、不可数名词\n\n\n/\n可数名词\n不可数名词\n\n\n\n能否 【计数】\n✅\n❌\n\n\n能否【加不定冠词（a/an）和数词（one、two）】\n✅\n❌\n\n\n能否【加定冠词（the）】\n✅\n✅\n\n\n可数名词（单数复数都可以，可以加数词计算）：\n\napple\negg\nboy\n\n不可数名词（只能单数，不可以加数词计算）：\n\nwater\nfire\ntime\n\n具体名词、抽象名词具体名词（看得见摸得着、可数不可数都有）：\n\nman\nBeijing\nbook\nfire\n\n抽象名词（无形的各种事物，大多数不可数）：\n\ntime\nhope\nlove\n\n单复数变化规则变化\n直接 + s：coats、jobs、hats\n以 o，s，x，ch，sh 结尾，+ es：dresses, boxes, watches\n辅音（除去A、E、I、O、U的 21 个字母） + y，变 y 为 i 加 es：cities\n以 f 或 fe 结尾，变 f 为 v 加 es：half =&gt; halves; wife =&gt; wives\n以 o 结尾\n有生命 + es：patato =&gt; patatoes; tomato =&gt; tomatoes\n无生命 + s：photo =&gt; photos; zoo =&gt; zoos\n\n\n\n不规则变化\nman =&gt; men\nwoman =&gt; women\ngoose =&gt; geese\nfoot =&gt; feet\ntooth =&gt; teeth\nchild =&gt; children\nmouse =&gt; mice\nfish =&gt; fish\nsheep =&gt; sheep\ndeer =&gt; deer\n\n一直是复数的名词\nglasses 眼镜\nclothes 衣服\nscissors 剪刀\ntweezers 镊子\ncongratulations 祝贺\ntrousers 裤子\namends 赔偿\ncahoots 同伙\nshenanigans 恶作剧\nsmithereens 碎片\n\n复合名词的变化\nman 或 woman 做前缀，前后都要复数：man actor =&gt; men actors\n两个名词，后面变复数：boy friend =&gt; boy friends\n可数名词 + 介词（短语），前面名词复数：sister in law =&gt; sisters in law\n动词/过去分词 + 副词，加 s：stand by =&gt; stand bys\n中间含有连字符，则在主体名词之后加复数词尾：stander-by =&gt; standers-by\n\n名词所有格‘s 所有格(中英序一致)单数名词、复数名词非 s 结尾，后加’s, 单数名词 s 结尾，也加’s,如：\n\nJack’s 杰克的\nThe boss’s car 老板的车\n\n复数名词以 s 结尾，后加’, 如：\n\nBoys’\n\n用 and 连接并列名词时：\n\n要表示各自的所有关系，则分别加’s\nTom’s and Jack’s rooms. （汤姆的房间和杰克的房间）\n\n\n共同关系，只在最后一个名词加’s\nTom and Jack’s rooms. (汤姆和杰克的房间)\n\n\n\n其他常见用法\n\n日程时间\n3 day’s holiday.(三天的假期)\n\n\n国家城市\nBeijing’s policy\n\n\n地方机构\nThe airport’s service guide\n\n\n各种单位\n100 kilogram’s weight.\n\n\n天体\nThe Jupiter’s aura（木星的光环）\n\n\n\nof 所有格(中英反序)\n\n\n\n\n\n\n\n\n修饰前面的名词，表两个名词之问的所属关系\n\nThe content of the book = The book’s content这本书的内容\n\n‘s+of 双重所有格\nof + 名词’s\nThis is a photo of my cat’s. （这是我的猫的照片）\n\n\nof + 名词性物主代词\nHe is a friend of mine.\n\n\n\n名词主谓一致\n\n\n\n\n\n\n\n\n主谓一致就是主语和谓语的单复数保持一致\n\nI(单) am(单) a student.\nThey(复) are(复) students.\n\n谓语用单数的情况专有名词谓语用单数\n\nThe United States was founded in 1776.\n美国建立于1776年\n“Three Kingdoms” is a good story.\n三国演义是个好故事\n\n【many a】 或 【more than one + 名词】做主语\n\nMany a man is smoking.\n很多男人在抽烟\nMore than one man is smoking.\n不止一个男人在抽烟\n\n【one and half + 复数名词】做主语\n\nOne and half watermelons is in the fridge\n冰箱里有一个半西瓜\n\n时间、钱、距离等【单位】看做整体\n\nTwo doollars is no big deal.\n两美元没什么大不了\nFour miles is not a long way.\n四英里的路不远\n\n加减乘除运算中，谓语用单数\n\nFive times five is twenty-five\n5乘5是25\nOne plus one is two\n1加1是2\n\nOthereach, one, no one, some(any, no, every)+body(one, thing)作主语或限定词\n\nEach student is in the classroom\n每个学生都在教室里\nSomeone student is in the classroom\n某个学生在教室里\n\n【one of + 复数名词结构】\n\nOne of the students in our school is from the United States\n我们学校有一名来自美国的学生\n\n集体概念的名词：根据 Context 进行判断，【整体】概念谓语用【单数】，【个体】概念谓语用【复数】\n\nThe family was in a poor way.\n这个家庭生活贫困。（整体）\nThe family goes to the movies together.\n这家人一起去看电影。（个体）\n\na number of + 可数名词复数 =&gt; 谓语用复数\n\nA number of scientists are a single.\n许多科学家都是单身\n\nthe number of + 可数名词复数 =&gt; 谓语用单数\n\nthe number of scientists in the lab is five.\n实验室里有五名科学家\n\n就近原则(由距离谓语近的名词决定单复数)There, Here:\n\nThere is one computer and two phones.\nThere are two computers and one phone.\nHere is one apple and two bananas.\nHere are two apples and one banana.\n\nor / either…or…(二选一) / neither…nor…（两者都不选，选另一个）, not only…but…(also)（不仅而且，两个都）连接并列做主语：or:\n\nHis friends or he was dead.\nHe or his friend were dead.either…or…:\nEither my brothers or mother is going the garden.\n\n代词（pron.）\n\n\n\n\n\n\n\n\n代词的种类繁多，最重要的是要掌握用法，不用太拘泥于他们的分类以及语法术语\n代词就是用来代替名词的词。可以在句子中做主语、直接宾语、间接宾语、介词宾语\n人称代词指代人、地点、事物、想法，例如：\n\nI\nme\nshe\nwe\nus\nit\nyou\nthey\n\n物主代词表示名词的所有权关系，例如：\n\nMy\nour\nyour\nhis\nher\nits\ntheir\n\n反身代词反身代词用于指代句子的主语，以“-self”（单数）或“-selves”（复数结尾），例如：\n\nmyself\nyourself\nyourselves\nourselves\nhimself\nherself\nitself\nthemself\n\n指示代词指代已经提到的名词，如：\n\nthis\nthat\nthese\nthose\nsuch\nnone\nneither\n\n不定代词many; muchmany: 代替可数名词的复数\nmuch：代替、修饰不可数名词\n后接可数名词复数：a few（肯定意义）一些; few（否定意义）几乎没有\n后接不可数名词：a little（肯定意义）一些; little（否定意义）几乎没有\n例如：\n\na few carrots 一些胡萝卜\nfew carrots 很少（几个）胡萝卜\na little water 一点水\nlittle water 很少水\n\nsome; anysome：一些（一般用在肯定句中）\nany：一些（一般用在否定句、疑问句中）\n例如：\n\nThe rabbit needs some carrots.\nDoes the rabbit need any carrots?\nThe rabbit doesn’t need any carrots.\n\n如果需要对方正面肯定的回答时也会用 some，例如：\n\nWould you like some coffee?\n\n当 any 表示“任何一个”的时候，可以用在肯定句中，例如：\n\nThe rabbit can eat any carrot.\n兔子可以吃任何一个胡萝卜\n\neach; everyeach 和 every是“每”的意思，后接单数，例如：\n\neach carrot / every carrot\n\neach 可以作代词，单独作主语，而每不可以单独作主语，需要后面 + 名词，例如：\n\nThere are many carrots. Each （✅） is big.\nThere are many carrots.Every（❌） is big. \n\neach 表示 2 个或 2 个以上，every 表示 3 个或 3 个以上，例如\n\nThere are many carrots on each side of the street.（✅）\nThere are many carrots on every side of the street.(❌)\n街道两旁有胡萝卜\n\neither; neithereither、neither做主语时：\neither: 两者中的每一个（谓语用单数）\nneither: 两者中每一个都不（谓语用单数）\n例如：\n\nGive the rabbit this or that carrot. Either is good.\n给兔子这个或那根胡萝卜，（两者中）哪一个都很好\n\n\nDon’t give the rabbit this or that carrot. Neither is good.\n不要给兔子这根或那根胡萝卜。（两者中）哪一个都不好\n\n\nEither of the carrots is good.\n（两个）胡萝卜哪一个都很好\n\nboth; allboth: 都；全部。both 是指两者都，例如：\n\nBoth of the two rabbits are cute.\n两只兔子都很可爱\n\nall: 都；全部。all 是指“三者及以上都”，例如：\n\nAll of the rabbits are cute.\n全部兔子都很可爱\n\nother; the other; anotherother: 另外的；其他的（+名词），例如：\n\nI like this carrot. I don’t like other carrot.\n\nthe other： 特指两者中的一个，例如：\n\nThis carrot is bigger than the other carrot.\n\nanother: 泛指 3 个或 3 个以上另一个，例如：\n\nThe rabbit doesn’t like this carrot. Give him another carrot.\n\none; it\nThe rabbit doesn’t like this carrot. Give him another one.\n\n复合不定代词\n\n\npron\n人\n物\n\n\n\nevery\neveryone/everybody 每人；人人\neverything 每件事；一切事\n\n\nsome\nsomeone/somebody 某人\nsomething 某事\n\n\nany\nanyone/anybody 任何人\nanything 任何事\n\n\nno\nno one/nobody 没人\nnothing 没有事\n\n\n形容词在修饰复合不定代词时要后缀，例如：\n\nThe rabbit has something important to do.\nThe rabbit has nothing important to do.\n\n疑问代词疑问代词用于发起提问，如：\n\nwho\nwhat\nwhich\nwhose\n\n例句：\n\nWhich video did you like the best?\nWhose bag is this?\n\n连接代词\n\n\n\n\n\n\n\n\n要理解连接代词必须先理解从句\n连接代词引导主语从句，宾语从句和表语从句\n连接代词有：\n\nwho\nwhom\nwhose\nwhat\nwhich\nwhoever\nwhomever\nwhatever\nwhichever\n\n“-ever”表示“任何，一切”的意思，起强调作用\n例句：\n\nI don’t know who you are.（who 引导宾语从句）\n\n我不知道你是谁\n\nWhat he said isn’t true.（what 引导主语从句，what 在此表示说话的内容）\n\n他说的话不是真的\n\nThe important thing is which rabbit is smarter.（which 引导表语从句）\n\n重要的是哪只兔子更聪明\n\nThe rabbit wants to eat whatever he likes.\n\n兔子想吃他喜欢的任何东西。\n\n\n关系代词关系代词专用于定语从句，共有六个：\n\nwho\nwhom\nwhose\nwhich\nthat\nas\n\n例句：\n\nThe rabbit who became hungry ate a carrot.\n饿了的兔子吃了根胡萝卜\nThe rabbit whom I saw ate a carrot.\n我看见的那只兔子吃了根胡萝卜\nThe rabbit whose ears are long ate a carrot.\n那只耳朵长的兔子吃了根胡萝卜\nThe rabbit ate the carrrot which / that I bought.\n兔子吃了我买的胡萝卜\nThe rabbit ate the carrot, as was expected.\n兔子如预料的那样吃了胡萝卜\n\n介词（prep.）介词用法定语\nThe method of success.\n\n成功的方法\n状语\nShe lives in Vancouver.\n\n她住在温哥华\n表语\nIt is in the right screw.\n\n它是一个正确的螺丝\n宾补\nHe put the cellphone on the desk.\n\n他把手机放在桌子上\n同位语\nAs a doctor, he is responisble for his patient.\n\n他作为医生，他对他病人负责\n\n\n介词分类按结构分\n单个介词\nat\nin\nof\nafter\n\n\n合成介词\ninto\ninside\noutside\n\n\n分词介词\nincludeing\nconsidering\n\n\n短语介词\nin front of\nby way of\nat the end of\naccord of\n\n\n\n按词义分\n地点\n方向\n时间\n方式\n涉及\n目地\n原因\n比较\n伴随\n\n介词易混地点on、in、at\nat 某个具体位置、加小地点\nAt bus station\nAt No.12 avenue\n\n\nin 后面跟大地点\nIn Beijing.\n\n\non 表示在上面，后面加楼层\nOn the 1st floor.\n\n\n\n时间 on、in、at\nat 后面跟具体时刻，一天中的具体时间点，具体的周和节日\nAt midnight\n\n\non 后面跟具体的时间，某年某月某日星期几\nOn Monday September 2nd 2019.\n\n\nin 后面跟年、月、早晚、季节，一段时间，将来时中表示一段时间之后\nIn Spring.\nWe will meet in a few days.\n\n\n\n方位 on、in、to\nin 是 a 在 b 里面\nKunming lies in the southwest of China.\n\n\non 是 a 和 b 连着\nCanada lies on the north of American.\n\n\nto 是 a 和 b 不连着\nJapan lies to the east of China.\n\n\nto 表示方向\nto the south.\n\n\non 表示左右\non the left.\n\n\n\n时间 after、in\nafter + 具体时刻或者从句：表示在什么时刻之后，跟一般时态\nI was always playing football after school.\n我放学后总是踢足球\n\n\nin + 一段时间：表示在多久之后，跟将来时态\nWe will study math in a new semester.\n我们将在新学期学习数学\n\n\n\n时间 since、for\nsince + 具体时刻或者从句：自从什么时候起，一直到现在\nSince Ford died, that’s all changed.\n自从福特死了，这一切都变了\n\n\nfor + 一段时间：总共有多长之久\nThe school history for two hundred years.\n这学校历史长达 200 年\n\n\n\nin the front of、in front of\nin front of 表示在某物范围外的前面\nThere is a tree in front of the school.\n学校前面有一棵树\n\n\nin the front of 表示在某物范围内的前面\nWe sit in the front of the bus.\n我们坐在公交车的前面\n\n\n\nby、in、with\nby 乘坐交通工具、以什么方式\nI have to go by bus.\n我不得不坐公交车去\n\n\nin 使用某种语言文字\nHe has a speech in English today.\n他今天发表了一篇英文演讲\n\n\nwith 使用某种工具方法\nBlending with Light\n光合作用\n\n\n\nthrough、across、over\nthrough穿过、通过森林、人群、门等等\nIt passes through the Alataw Pass inhto Kazakhstan.\n它通过阿拉山口进入哈萨克斯坦\n\n\nacross和 over 跨越、跨越过河流、街道、围墙\nI run across the street.\n我跑过马路\nI climbed over the fence\n我翻阅围墙\n\n\n\nunder、below、beneath\nunder在…之下，表示某物接触或覆盖某物时\nWe finished the project in under a year.\n\n\nbelow 某物低于某物、或者表示温度用\nBelow freezing.\n冰点以下\n\n\nbeneath 在…之下（抽象概念），能力、地位、期望低\nThe game is beneath my expectations.\n这游戏低于我的预期\n\n\n\nin、into\nin 在…里面\nI walk in the school.\n我在学校里走\n\n\ninto 朝着…里面去\nI walked into the school.\n我走进了学校\n\n\n\n介词搭配\n介词+名词\nfor your car\n\n\n介词 + 代词\nwith her\n\n\n介词 + 动名词\nfor coming here\n\n\n介词 + 形容词\nfrom young to old\n\n\n介词 + 副词\nsince then\n\n\n介词 + 动词\nof winning\n\n\n介词 + 不定式\nto make him angry\n\n\n介词 + 从句\nat which I fell asleep was very boring.\n\n\n介词 + 数词\nover 100 people\n\n\n介词 + 介词\njust before us\n\n\n\n动词（v.）动词分类能做谓语实意动词vi.、vt.\n\n及物动词(vt.)，后面加宾语\nI hate you.\n\n\n不及物动词(vi.)，后面不加宾语\nI fly.\n\n\n及物+不及物动词（根据情况加宾语）\nI stop.(我停下)\nI stop working.(我停下工作)\n\n\n不及物动词没有被动句，因为它后面不能加宾语\n\n系动词引导表语或表语从句\n\nbe 动词\nam\nis\nare\n\n\n感官动词\nfeel\nlook\nsmell\nsound\nseem\n\n\n变化动词\nget\nbacome\nturn\ngrow\n\n\n保持动词\nkeep\nstay\nremain\nrest\n\n\n\n静态动词表示拥有、情感、思想的动词\n\n拥有\nhave\nown\nwant\ncontain\n\n\n情感\nlove\nhate\nwant\nneed\n\n\n思想\nknow\nthink\nunderstand\nbelieve\n\n\n\n动词短语TODO\n不能做谓语助动词协助主要动词构成谓语的词，没有实际意思，不能单独使用，构成时态、语态、否定句、强调句、疑问句\n\nhave 做助动词，构成完成时：\nI have turned off the light.\n我已经把灯关了\n\n\ndo 做助动词，构成疑问句、否定句、强调句\nDo you have kids?\n你有孩子吗？\nI do not know.\n我不知道\nDo come with you.\n一定要跟你去\n\n\nbe 动词做助动词，构成进行时或被动语态\nI am watching this video.\n我正在看这个视频\n\n\n\n情态动词情态动词有含义，和动词原型一起构成谓语\n\ncan/could 表示推测、允许、能力\nYou can imagine the story is bad.\n你可以想象这个故事不好\nYou could have been hurt.\n你可能会受伤\n\n\nmay/might 表示推测、允许、请求、祝愿\nIt may rain today.\n今天可能下雨\nI might be the next lucky dog.\n我可能是下一个幸运儿\n\n\nmust 表示肯定推测、命令\nIt must be her.\n这一定是她\nYou must choose.\n你必须选择\n\n\nshould/shall/ought to 表示推测、需要、征求意见\nYou should be careful.\n你要当心\nShall we regain the shore alive?\n我们能活着回到岸上吗？\n\n\nWould/will 表示将要、请求、意愿\nWould you like to come with me?\n你要跟我一起来吗？\n\n\nbe able to 能够\nhave to 必须\nhad better 最好\n\n动词形式动词形式决定时态\n原形\n与助动词与情态动词一起构成谓语，要用原形\nDo you like English?\n你喜欢英语吗？\n\n\n祈使句的谓语动词，要用原形\nDon‘t move.\n别动\n\n\n感官动词的宾语与宾补构成逻辑上的主谓关系，表示动作的最后结果或全过程时，作宾补的动词要用原形\nI heard a coin drop.\n我听到一个硬币掉了下\n\n\n使役动词后的宾语与作宾补的动词构成逻辑上的主谓关系时，动词要用原形\nHe let Jack lead the way.\n他让杰克在前面带路\n\n\n两个以上的并列不定式用 and 或 or 连接起来，动词要用原形\nLet’s go and play football.\n我们去踢球\n\n\n在 why not…和 why…句型中，not 和 why 直接跟动词原形，构成反问，表示“建议、劝告、责备或提醒”等。\nWhy not use my bicycle?\n为什么不用我的自行车呢？\n\n\n动词 help 后是宾+宾补，其宾补由动词充当时，动词用原形\nI was helped to clean the room by her.\n她帮我打扫房间\n\n\n**do, does, did **与动词原形连用\nDo be careful!\n一定要当心！\n\n\n不定式作介词 but 和 except 的宾语，前面有实意动词 do 时，后面的动词不定式要省略 to\nJack had nothing to do but/except watch TV.\n杰克除了看电视外无事可做\n\n\n固定的句型中，用原形\nhad better（最好）\nYou had better have a good rest.\n你最好好好休息一下\n\n\nwould rather(宁愿)\nI would rather study at home\n我宁愿在家学习\n\n\nwould rather … that … (宁愿…而不)\n\n\n\n第三人称单数一般现在时，主语是第三人称单数时，谓语要用第三人称单数第三人称单数：\n\n人称代词：he she it\n单个人名\n地名\n单数可数名词\n不可数名词\n\n例句：\n\nIt looks like a cat\nBeijing is in China\nThe cat is Lucy’s.\nThe water is very cold.\n\n动词变第三人称单数：\n\n直接在动词结尾加 s\n以 s、x、ch、sh、o 结尾加 es\n辅音字母加 y 结尾，y 变成 i 加 es\n不规则变化\nhave =&gt; has\nbe =&gt; is\n\n\n\n动名词和现在分词\n动名词起着名词的功能，常在句子中充当主语、定语、表语等成分\n现在分词来构成进行时态，与助动词 be 搭配构成句子的谓语，现在分词在句子中还可以充当定语、表语和状语\n\n\n词尾加 ing\nplay -&gt; playing\nworking\n\n\n词尾是 e 去掉 e 加 ing\nride -&gt; riding\n\n\n词尾是 ie 把 ie 变成 y 加 ing\ntie -&gt; tying\n\n\n辅音加元音加辅音双写辅音加 ing\nbeg -&gt; begging\n\n\n\n过去式和过去分词过去式单独做谓语，表示过去某个时间发生动作\n\n加 ed\nplay -&gt; played\n\n\ne 结尾加 d\nlove -&gt; loved\n\n\n\n过去分词是动词的非谓语形式，表示被动或完成\n\n\n\n动词\n过去式\n过去分词\n\n\n\narise\narose\narisen\n\n\nbe\nwas\nbeen\n\n\n\nwere\n\n\n\nbabysit\nbabysat\nbabysat\n\n\nbeat\nbeat\nbeaten\n\n\nbecome\nbacame\nbecome\n\n\nbend\nbent\nbent\n\n\n动词时态\n\n\n\n\n\n\n\n\n动词时态 = 动作的时间 + 动作的状态\n使役动词副词（adv.）副词的主要目的就是更精确地描述，补充，修饰各类词性\n副词的用法副词修饰哪些词性\n修饰动词\nThis rabiit runs fast\n\n\n修饰形容词和副词\nThis is a very fast rabbit\nThis rabbit runs very fast.\n\n\n修饰名词\nThis rabiit here runs very fast.\n\n\n修饰句子\nObviously, this rabibit here runs very fast.\n\n\n\n副词在句子中作什么成分\n状语，定语\n表语(主语补语)\nThe worf is broad.\n\n\n宾语补语\nLet me in!\n\n\n\n副词的形式\n同拼写，同义、近义\nfast（快）\n\n\n同拼写，异义\npretty(漂亮，相当)\n\n\n副词 = 形容词 + ly，同义、近义\nquick, quickly(快)\n\n\n副词 = 形容词 + ly，异义\nlarge (大)\nlargely (基本上)\n\n\n\n副词的种类方式副词方式副词可以位于句首，句中，句尾，但不是所有方式副词都可以\n\nSuddenly, the driver turned left.\nThe driver suddenly turned left.\nThe driver turned left suddenly.\n\n程度副词程度副词一般位于它修饰的形容词或副词之前。\n\nThis is a very fast rabbit.\nThis cat runs very fast.\n\n地点副词地点副词一般出现在句尾；表强调时也可以位于句首\n\nThe rabbit eats carrots indoors / outdoors.\n\n这兔子在室内、室外吃胡萝卜\n\nThe rabbit eats carrots upstairs / downstairs.\n\n这兔子在楼上、楼下吃胡萝卜\n\nHere you can relax and forget about all your troubles.\n\n在这里你可以放松并忘记所有烦恼\n\n\n时间副词一般位于句尾：\n\nThe rabbit ate some carrots yesterday.\nThe rabbit is eating some carrots now.\nThe rabbit will eat some carrots later.\n\n也可放句首、或居中：\n\nThe rabbit has already eaten some  carrots.\n兔子已经吃了些胡萝卜\n\n频率副词大多数位于行为动词之前，be 动词、助动词、情态动词 之后\n\nThe rabbit eats carrots every day.\nSometimes, the …\nThe rabbit usually …\nThe rabbit eats carrots three times a day.\nI will always love you.\n\n疑问副词疑问副词是用来构成特殊疑问句的副词\n\n对方式提问\nHow does the rabbit eat carrots?\n\n\n对地点提问\nWhere does the rabbit eat carrots?\n\n\n对时间提问\nWhen does the rabbits eat carrots?\n\n\n对原因提问\nWhy does the rabbit eat carrots?\n\n\n\n连接副词引导名词性从句的副词\n\nHow the rabbit eats carrots is interesting.(How主语从句)\nI dont’s know where the rabbit eats carrots.（where引导宾语从句）\nThat is why the rabbit eats carrots.（why引导表语从句）\n\n关系副词引导形容词性从句（定语从句）\n\nThis was the place where the rabbit ate the carrot.\nThis is the reason why the rabbit ate the carrot.\nThat was the day when the rabbit ate the carrot for the first time.\n\n句子副词一般在句子的开头，用逗号和主句分开\n\nObviously, this rabbit here runs very fast.\n\n形容词（adj.）形容词的用法定语前置定语\na hungry rabbit\na little white rabbit\n\n顺序：限定词 + （主观）特征 + 尺寸 + 形状 + 新旧 + 颜色 + 来源 + 材料 + 用途例如：a beautiful big round new black Chinese wooden table中文：一张崭新的漂亮的黑色中式木质大圆桌\n后置定语比如，形容词修饰符合不定代词\n\nsomebody\nsomebody nice\n某个好人\n\n\nanybody\nanybody absent\n不在场的人\n\n\neverything\neverything possible\n所有可能的事儿\n\n\nnothing\nnothing wrong\n没不对的事儿\n\n\n\n形容词短语作定语一般，形容词短语会放在描述的对象之后，比如：\n\ncarrots good for the rabbit\n对兔子有好处的胡萝卜\nthe rabbit eager to eat carrots =&gt; the rabbit tat is eager to eat carrots\n急于吃胡萝卜的兔子\nthe rabbit busy eating carrots =&gt; the rabbit that is busy eating carrots\n忙着吃胡萝卜的兔子\n\n表语\nThe rabbit is alive / asleep / alone.\n兔子是活的/睡着的/孤单的\nthe only rabbit alive\n唯一一只活着的兔子\n\n补语\nCarrots make rabbits happy.\n胡萝卜让兔子开心。\n形容词 happy 补充说明了宾语 rabbit的状态，作宾语补语\n\n状语\nThe rabbit came home, tired and hungry.\n兔子回到家，又累又饿\ntired and hungry 表示兔子回到家时的状态，作状语\n\n形容词的构成简单形容词例如：\n\nhungry\nlittle\nwhite\n\n复合形容词现在分词和过去分词也可以做形容词形容词 + 形容词/现在分词/过去分词：\n\na red-hot coal\na good-looking rabbit\na new-born baby\n\n副词可以放在形容词前修饰形容词，副词 + 形容词/现在分词/过去分词：\n\nall-round\nhard-working\nrecently-built\n\n形容词/数词 + 名词（需要+ed，与过去式无关）：\n\nwhite-haired = … whose hair is white\n\n白发的\n\nkind-hearted = … whose heart is kind\n\n好心的\n\na long-distance call\n\na one-way street\n\n\n名词 + 形容词/现在分词/过去分词：\n\na snow-white rabbit = a rabbit that is white like snow\n\n一只雪白的兔子\n\na carrot-eating rabbit = a rabbit that eats carrots.\n\n一只吃胡萝卜的兔子\n\na heart-broken rabbit = a rabbit that heart is broken.\n\n一只心碎的兔子\n\n\n比较级&amp;最高级构成音节少的词，一般构成是形容词+er, est，有些需修改拼写以防误读音节多的词，一般构成是more, most + 形容词\n表达意义比较级通常表达“更….”、“越…越…”最高级一般表达“最”，但也可能是“非常”\n连词（conj.）并列连词连接有着“并列的，同等语法地位的”单词，词组或句子。\n并列关系\nThe cat is small and cute.\nBoth the rabbit and the wolf like carrots.\nThe rabbit not only teaches English but also makes videos.\n\n\nThe rabbit likes neither apples nor pears.\n兔子既不喜欢苹果也不喜欢梨子\n\n\nNeither the rabbit nor the wolf likes apples.\n兔子和狼都不喜欢苹果\n\n选择关系\nWhat does the rabbit like? Apples or carrots?\n\n兔子喜欢什么？苹果还是胡萝卜？\n\nEither the rabbit or the wolf is going to the party this evening.\n\n不是兔子就是狼会去要参加今晚的聚会\n\n\n表否定：\n\nThe rabbit neither ate nor slept yesterday.\n兔子昨天既没吃也没睡\nHurry up, or / or else / otherwise you’ll be late.\n快点，否则你要迟到了\nEither the rabbit or I am going to the party this evening. \n不是兔子就是我将要参加今晚的聚会\n\n转折关系\nThe rabbit cooked some carrots, but he didn’t eat any.\nThe rabbit cooked some carrots, yet he didn’t eat any.\nI haven’t eaten yet(adv.), yet(conj.) I’m not hungry\n\n因果关系\nThe rabbit is busy, so he won’t go to the party tonight.\n兔子很忙，所以今晚他不能参加聚会了（前因后果）\n\n\nThe rabbit is busy. Therefore, he won’t go to the party tonight.\n兔子很忙，所以今晚他不能参加聚会了（前因后果）\n\n\nThe rabbit will skip lunch, for he is busy making a video.\n兔子不吃午餐了，因为他在忙着做视频（前果后因）\n\n从属连词引导名词性从句that 当引导主语从句、宾语从句、表语从句和同位语从句时：\n\n只起连接作用\n在句子中没有实际的意义\n在宾语从句中可以省略。\n\n例句：\n\nThat the rabbit ate the carrot was obvious.\n兔子吃了胡萝卜，这很明显（主语从句）\n\n\nI saw (that) the rabbit ate the carrot.\n我看见兔子吃了胡萝卜（宾语从句）\n\n\nI don’t know if the rabbit ate the carrot.\n我不知道兔子是否吃了胡萝卜（宾语从句）\n\n\nThe fact is that the rabbit ate the carrot.\n事实是兔子吃了胡萝卜（表语从句）\n\n\nThe question whether the rabbit will eat the carrot is on all our minds.\n兔子是否会吃胡萝卜这个问题萦绕在我们心中（同位语从句）\n\n引导状语从句引导时间状语从句的连词：\n\nwhen 当…时候\nwhile 当…时候\nas 当…时候\nbefore 在…之前\nafter 在…之后\nuntil 直到…为止\nsince 自…以来\n\n引导地点状语从句的连词：\n\nwhere 在…地方\nwherever 无论在…地方\n\n引导比较状语从句的连词：\n\nthan 比\nas 与…一样…(出现在as…as…结构中)\n\n引导条件状语从句的连词：\n\nif 如果\nunless 除非\n\n引导让步状语从句的连词：\n\nalthough 虽然；尽管（不与并列连词but连用）\nthough 虽然；尽管（不与并列连词but连用）\neven though 即使\neven if 即使\nwhile 虽然；尽管\n\n引导方式状语从句的连词：\n\nas 像…；与…一样\nas if 好像\nas though 好像\n\n引导原因状语从句的连词：\n\nbecause 因为（从属连词；不与并列连词so连用）\nsince 因为（表示间接、附带原因，语气弱于 because）\nas 因为（语气最弱）\n\n引导目的状语从句的连词：\n\nin order that 目的是…;为了 …\nso that 以便\nso 以便\n\n引导结果状语从句的连词：\n\nso…that… 太…以至于…（注意与 so that 区分）\nsuch..that… 太…以至于…\nso 因此；所以\n\n感叹词（int.）\n\n\n\n\n\n\n\n\n负责表达情感的声音，单词，词组\n具体可见视频：https://www.bilibili.com/video/BV1XY411J7aG?p=20&amp;vd_source=0102e1b36cb805c77386e59559a89b2c\n从句名词性从句主语从句用一个句子代替句子里的一个名词，做句子主语\n主语从句引导词：\n连词：\n\nthat\nwhether\n\n代词：\n\nwho\nwhoever\nwhom\nwhose\nwhat\nwhatever\nwhich\nwhichever\n\n副词：\n\nwhen\nwhere\nhow\nwhy\nwhenever\nwherever\nhowever\n\n主语从句经常用形式主语 it 放主语位置,真·主语后置：\n\nThat he will the match is certain.\nIt is certain that he will win the match.\n\n宾语从句表语从句同位语从句定语从句（形容词从句）思维方式The rabbit is eating a carrot.\n构成限定性和非限定性翻译技巧https://www.bilibili.com/video/BV1ov411r7L6Q：什么是定语？A：中文翻译为 xxx 的词（定语就是形容词）\nQ：什么是定语从句？A：连词+句子，作形容词修饰名词\n定语从句的位置问题中文里面，定语在名词前面（eg.漂亮的女孩）英语里面，定语：\n\n单个词的，一般放名词前，除了：\n不形：不定代词+形容词\na 形：something important a boy asleep. \n过去分词（前后都行）\n\n\n从句，后置\n\n翻译题做题步骤先拆分句子！\n\n连词处（从句）\n介词处（作定语或状语）\n非谓语（作定语或状语）\n标点符号\n\n练习例句：\n\nWe are obliged to them because some of these languages have since vanished, as the peoples who spoke them died out or became assimilated and lost their native languages.\nThere will be television chat shows hosted by robots, and cars with pollution monitors that will disable them when they offend.\n\n连词前是动词、介词 -&gt; 宾语从句连词前是名词 -&gt; 定语从句\n! 如果英文中有被动，翻译成中文要变成主动\n状语从句(副词从句)参考资料\nhttps://www.bilibili.com/video/BV1Z4411C7jG\nhttps://www.bilibili.com/video/BV1XY411J7aG\nhttps://wordvice.cn/topic/category/language-rules\n\n核心语法(刘晓燕考研英语)\n\n\n\n\n\n\n\n\nhttps://www.bilibili.com/video/BV1ft4y1Q74v\n简单句什么是英语句子必须具备主谓结构，主语一定是谓语动作的发出者，如果有宾语的话，宾语一定是谓语动作的承受者\n句子的基本结构1. 主谓2. 主谓宾谓语：实义动词（有实际意义的动词）\n3. 主系表谓语：系动词:\n\nbe\n感官动词：look（=seem=appear）、smell（n. 气味）、taste（n. 喜爱 爱好）、sound、feel\n变化：become, get，turn, grow, fall\n保持：keep，stay，remain，stand\n表象：seem, appear\n终止：prove\n\n4. 主谓双宾5. 主谓宾宾补只需要在两个宾语之间加个 be 动词，如果读起来意思是对的，就是主谓宾宾补，如果读起来意思不对就是双宾\n句子的成分（词性的问题）谓语1. 谓语的成分有时态的实义动词或系动词充当谓语\n2. 一句话当中动词能不能多？\n不能多\n\n一句话当中只能有一个动词，并且充当谓语，多余的动词全部都要变成非谓语动词。\n\n❌ Laugh at others is my hobby.\n\n✅ Laughing at others is my hobby.\n\n❌ I enjoy see movies.\n\n✅ I enjoy seeing movies.\n\n❌ My dream is become a rich lady.\n\n✅ My dream is to become a rich lady.\n\n\n谓语只能是动词，动词只能做谓语。要把一句话当中不是谓语的动词变成不是动词（非谓语动词）：\n\nV + ing 表示主动\nV + ed 表示被动\nto + do 表示目的\n\n3. 一句话当中动词能不能少\n不能少，当一句话需要动词而没有动词的时候，永远都加 be 动词，并且 be 动词没有意思。\n❌ Your mother must very beautiful.\n✅ Your mother must be very beautiful.\n❌ I against you.\n✅ I am against you.\n\n4. 谓语的总结一句话当中，有且只能有一个有时态的实义动词或系动词的存在，并且充当谓语。\n谓语练习\n他穿上外衣，锁上门，离开了家。\nHe putting on his jacket, locking the door, left home.\n大熊猫是熊科中最罕见的成员， 常居在中国西南部的森林里。\nPandas are the rarest members in bear family, mainly living in the fonest of Chinese South west\n长江流经不同的生态体系，是诸多濒危物种的栖息地，灌溉了中国五分之一的土地。\nYangZi River flowing through diverse ecological systems, keeps the home of a sea of endangered species, irrigoating Chinese 1/5 land.\n我爱你，你爱我\nI loveing you, you love me.(独立主格)\n冬天来了，春天就不远了\nWinter approaching, spring will be around the corner.\n我是一个老师，我很喜欢唱歌。\nBeing a teacher, I have passion for singing songs.\n\n主语1. 主语的成分\n名词\n\n代词\n\n非谓语动词\n\n从句（引导词+句子）\n\n❌ Handsome and strong are his nature.\n\n✅ Being Handsome and strong is his natrue.\n\n\n2. 一句话当中主语能不能少？不能一句话没有主语的时候怎么办？\n\n加 it 作为主语：必须与天气、温度、时间有关系\nthere be句型，听到“有”的时候使用。\nThere exist a host of undergraduates being fascinated with me.\n\n\n!!!被动：当听到一句话没有主语，或者人称代词做主语的时候，都可以考虑写成被动\n必须指出坚持很重要 =&gt; Persistence must be pointed out outstandingly crucial.\n越来越多的人认为过度捕捞很严重 =&gt; Overfishing is claimed more than fearful by an increasing amount of professors.\n\n\n\n三种情况无被动：\n\n动词后面有介词的话，该动词无被动\ngo to school\n\n\n系动词没有被动\nhave 翻译成“有”的时候，没有被动\n\n\n人称代词做主语：不到万不得已，最好不要使用\n\n3. 练习\n如果有梦想，就应该会成功\nIf there exists a dream, glories are supposed to be achieved.\n\n宾语（动词的承受者）主语和宾语的成分一样：\n\n名词\n代词\n非谓语动词\nI love to sing songs.\n\n\n从句\nI love you.\n\n\n\n表语\n名词\nI am a teacher.\n\n\n代词\nWho’s your best friend?\n\n\n非谓语动词\nMy dream is to become a poet.\nMy dream is becoming a poet.\n\n\n从句\n形容词\nI am beautiful.\n\n\n介词短语\nI am in Chongqing.\n\n\n\n简单句的考点分析写作\n所有写不来的长难句，暂时都先写成简单句，一定要保证语法正确。\n所有不会写的单词，都可以写成自己会的词汇\n\n长难句分析\n找谓语动词，找主谓宾\n有多个动词时找主句的动词，前面没有引导词的动词就是主句的动词\n\n并列句并列句就是用连词连接的两个句子\n并列连词\n平行：and, not only … but aloso …\n转折：but, yet, while, whereas\n选择：or, whether … or …\n因果：for, so\n递进：then\n\n逻辑关系词\n平行\nsimilarly\nequally\nlikewise\nat the same time / in the mean while\n\n\n转折\nhowever\nnevertheless\non the contrary / by contrast\nconversely\nunexpectedly\nunfortunately\n\n\n选择\nalternatively\n\n\n因果\ntherefor\nthus consequently\nas a result\n\n\n递进\nbesides\nfurthermore\nmoreover\nadditionally\nsubsequently\nin addition \n\n\n\n连词与副词、介词短语的区别\n使用连词时，可以加逗号，也可以不加\n其他逻辑关系词的前面，要么用句号，要么加连词 and\n\n考点分析写作只要写作的上下句之间有关系，就一定要用逻辑关系词（连词、副词、介词和介词短语）练习写句子：\n\n有朋自远方来，不亦乐乎\n\nThere remain an army of companies coming from afar, and consequently, I feel more than delighted.\n\n都说我如水百变，可知我清澈不变\n\nI am claimed changeable like water.By contrast, my clarity keeps consistent.\n\n还记得那天吗？我没有通过四级考试，一个人在雨中哭泣，你走过来，拍拍我的肩膀，告诉我人生没有终点\n\nDo you stiill keep that day in mind? I failed to pass CET4, and as a result, I shed tears in the rain alone. At the same time, you came up to me and subsequently you beat my shoulder and told me “thare exists no destination in life”.\n\n\n完形填空只需要读懂逻辑关系词前后两句话的意思即可\n长难句分析在分析长难句的时候，只要有并列连词的出现，通常都会有省略分析长难句的第二步就是找连词，但是在连词连接两个单词的时候，这个连词就装作没看见，无论何时\n\n如何查找省略的内容？\n一句话只要有省略，就一定会省略在连词后 -&gt; 所以连词后面有的成分，连词前面一定有 -&gt; 连词前面有而后面没有的成分就是省略的部分\n\n名词性从句名词能做什么成分\nThe movies looks terrific（充当主语）\nI admine his mother （充当宾语）\nGump is a man（充当表语）\nI enjoy the part, the beginning.（充当同位语）\n\n同位语：用来解释名词的成分\n\n只要在作文中见到名词，都可以有意识的在后面加个同位语，对该名词进行补充说明。\nPersistence, an active mentality, plays a critical role in the glories of all children and adults.\nMy mother, a typical housewife, enjoy playing Mahjong, a chinese enthertainment.\n\n同位语的成分（什么可以用来解释名词）：\n\n名词\n代词\n非谓语动词\n从句\n\n什么是名词性从句 名词在句子中能够充当的成分，从句都能充当，这就是名词性从句\n\nWhat I saw is attractive.\nI appreciate what she said.\nGump is who should learn from.\nI enjoy the part that a feather is flying in the sky.\n\n名词性从句的引导词\nThat he has got divorced is my fault.\nWhether has he got divorced is obvious.\nWho will he marry is a secert.\n\n名词性从句的引导词是按照从句的类型分的类，一共把引导词分为 3 类：\n\nThat: 当从句是陈述句时。并且 That 在从句中不充当任何成分，也没有任何意思。\nWhether: 当从句是一般疑问句时。并且 Whether 在从句中也不充当成分，意思是“是否”。\n所有的特殊疑问词：当从句是特殊疑问句时。 \n英语中所有的从句，都是陈述句的形式。\n\n练习句子：\n我正在思考外星人存在吗\n\nI am wondering whether aliens exist.(宾语从句)\n\n女人总是对的，是一个常识。\n\nThat ladies tend to be right remains common knowledge.\n\nIt remain common knowledge that ladies tend to be right.\n\n我的意思是，孝敬父母是中华民资的传统美德。\n\nMy meaning seems that supporting the elderly remains a chinese conventional virtue.（表语从句）\n\n有一天你会发现，事业、亲情、友情，都比爱情重要。\n\nSomeday, one will perceive that career, kinship and friendship prove more indispensovble than romance.(That 引导的宾语从句)\n\nThe point seems when wealth will become available for you.\n\n\n考点分析写作主语从句把主语从句放在句末，用 it 作形式主语。\n\nIt… that…\nIt is apparent that…\nIt looks beyond dispute that…\nIt has been widely accepted that…\nIt is universally acknowledged that…\nIt keeps my  argument that…\n\n主语从句的满分句型，可以写在作文中任何一句话前面练习：\n\n显而易见，关于勤奋这个话题已经引起关注了\nIt is looks beyond dispute that the issue about diligence has been brought into the limelight\n\n同位语从句The matter that he managed to find a girlfriend makes his superiours rejoiced.同位语从句既可以放在它所解释的名词后，也可以放在整句话的后面。\n\n没有什么能够掩盖他正在变老这个事实\n\nNothing can hide the truth that she is getting old.\n\n河南人都是骗子这种想法是不正确的\n\nThe outlook proves wrong that private individuals in HeNan seem all deceivers\n\n温室里的花朵，不能经受风雨，这个事实表明我们不该溺爱孩子\n\nThe evidence flowers in the greenhouse fail to undergo storms indicates that kids should by no means spoiled by thein.\n\n\n长难句分析能够识别各个名词性从句，并把他们通顺地翻译出来        \n如何识别主语从句\n只要见到有引导词放在句首，并且从句后没有被逗号隔开，就一定是主语从句。\n主语从句从 that 开始到谓语动词（组）结束。\nIt… that 通常都是主语从句。\n\n练习句子\n板块正在移动是毋容置疑的。\n\nThat the plates are moving is now beyond dispute.\n\nWhether the Government should increase the financing of pure science at the expense of technology or vice versa often depends on the issue of which is seen as the driving force.\n\n政府应该以牺牲技术增加对纯科学的投入，还是以牺牲纯科学为代价增加对技术的投入，这取决于哪一个问题被视为驱动力\n\nHow well the predictions will be validated by later performance depends upon the amount, reliability, and appropriateness of the information used and on the skill and wisdom with which it is interpreted.\n\n\n","slug":"english/grammar-note","date":"2022-09-28T03:19:49.000Z","categories_index":"英语","tags_index":"英语,笔记","author_index":"Jx"},{"id":"44e789181d3b4bef6dfcd4ebb07b6454","title":"Using Clash in Linux Server","content":"\n\n\n\n\n\n\n\n\nBackground: Too slow to install some dependent environments\nDownloadWe can go to the Clash Releases Page and find the corresponding system download address.The following demonstration with CentOS Linux 7 for x86.\nDownload using wget:\n\n\n\n\n\n\n\n\n\nIf direct wget is slow, you can use SFTP to upload to a Linux server after local download.\nwget https:&#x2F;&#x2F;github.com&#x2F;Dreamacro&#x2F;clash&#x2F;releases&#x2F;download&#x2F;v1.11.4&#x2F;clash-linux-386-v1.11.4.gz\n\nDecompression file Using gunzip and rename it to clash:\ngunzip clash-linux-386-v1.11.4.gz\nmv clash-linux-386-v1.11.4.gz clash\n\nAdd exceutable permissions to Clash:\nchmod +x clash\n\nConfigurationPut the clash configuration (config.yml, Country.mmdb) of your computer into the clash directory of Linux Server.\nYou can also download Country.mmdb manually by visiting this link.\nLaunchRunning Clash in the background:\nnohup .&#x2F;clash &amp;\n\nSystem ProxySetting system proxy in the shell:\nexport &#123;http,https&#125;_proxy&#x3D;127.0.0.1:7890\n\nVerifyVerify Proxy:\ncurl ip.gs\n\nVisit to Google:\ncurl google.com","slug":"system/Using Clash in Linux Server","date":"2022-08-07T01:34:49.000Z","categories_index":"操作系统","tags_index":"linux","author_index":"Jx"},{"id":"31cb8022faa8493f1aedc9b9cc8dea4f","title":"阿里云 ACP 云原生微服务","content":"\n\n考点总结\n","slug":"exam/AliyunACP","date":"2022-07-27T00:59:03.000Z","categories_index":"应试","tags_index":"考证","author_index":"Jx"},{"id":"6bdddc8b42ef6d479e6e06377184681c","title":"高等数学 - 笔记(updating)","content":"\n\n\n函数与极限无穷小与无穷大无穷小定义 1：如果函数  当  （或  ）时的极限为零，那么称函数  为当  （或  ）时的无穷小\n定理 1：在自变量的同一变化过程 （或） 中，函数  具有机极限的充分必要条件是 ，其中  是无穷小。\n无穷大定义 2：设函数  在  的某一去心邻域内有定义（或  大于某一正数时有定义）。如果对于任意给定的正数  （无论它多么大），总存在正数  (或正数  )，只要  适合不等式   （或 ），对应的函数值  总满足不等式\n那么称函数  是当  （或 ）时的无穷大\n定理 2：在自变量的同一变化过程，如果  为无穷大，那么  为无穷小；反之，如果  为无穷小，且 ，那么  为无穷大\n极限运算法则\n定理 1：两个无穷小的和是无穷小，有限个无穷小的和是无穷小\n\n定理 2：有界（sin, cos）函数与无穷小的乘积是无穷小\n\n推论 1：常数与无穷小的乘积是无穷小．\n\n推论 2：有限个无穷小的乘积是无穷小\n\n\n\n定理 3：如果 , ，那么\n\n（1）\n\n（2）\n\n推论 1：如果  存在，而  为常数，那么 \n推论 2：如果  存在，而  是正整数，那么 \n\n\n（3）若又有  ，则\n\n\n\n\n\n\n定理 4：数列极限暂时省略\n定理 5：如果，而，那么 \n\n","slug":"math/advanced mathematics","date":"2022-07-14T05:11:25.000Z","categories_index":"数学","tags_index":"高数","author_index":"Jx"},{"id":"5e7254d63639ed21d8e1e8e2812eb98c","title":"一些好用但鲜为人知的 Linux 命令","content":"系统监视UptimeUptime会返回服务器运行时长、当前时间、用户数量和内存使用平均数等信息。\n$ uptime\n\nWallWall可以向当前登录到系统的每个人的终端发送消息\n$ wall &quot;Your message&quot;\n\nTop实时显示 CPU 和内存使用情况的进程列表。\n$ top\n\nlsoflsof是一个单一的命令，用于一个基本的目的：List Open Files。这在遇到说文件被使用的挂载问题时特别有用。这个命令可以快速识别哪些文件被哪些进程使用。\n$ lsof\n\n网络NetcatNetcat、nc主要用于端口扫描，但实际上是一个伟大的实用网络工具，可供系统管理员在他们的后袋中用于任何任务。Netcat可以支持端口扫描、文件复制、端口转发、代理服务器和托管服务器……可以说，它的功能非常全面。\n# Example Usage:\n$ nc -vz &lt;host&gt; &lt;port&gt; # 检查给定端口上两个主机之间的连接\n$ nc -l 8080 | nc &lt;host&gt; 80 # 创建一个代理服务器\n\nNetstatNetstat返回各种网络的详细信息，如路由表（routing tables）、网络连接（network connections）、成员资格（memberships）、统计信息（stats）、标志（flags）等。\n# Example Usage \n$ netstat -a # 查看所有网络端口\n$ netstat -tlpn # 查看所有监听中的端口\n\n# Key Flags\n-s &#x3D; display networking statistics\n-v &#x3D; be verbose\n-r &#x3D; show routing tables\n-i &#x3D; display interface table\n-g &#x3D; show group memeberships\n\nNslookup用于获取网络或本地的服务器信息。它查询DNS以找到服务器信息，这对网络调试很有用。\n# Example Usage\n$ nslookup bilibili.com\nServer:\t\t183.60.83.19\nAddress:\t183.60.83.19#53\nNon-authoritative answer:\nName:\tbilibili.com\nAddress: 47.103.24.173\nName:\tbilibili.com\nAddress: 139.159.241.37\nName:\tbilibili.com\nAddress: 120.92.78.97\nName:\tbilibili.com\nAddress: 119.3.70.188\nName:\tbilibili.com\nAddress: 8.134.50.24\n# Key Flags\n-port &#x3D; Change port number for connection\n-type &#x3D; Change type of query. \n-domain &#x3D; Sets search list to name\n\nTCPDump用于捕获和分析进出你的系统的流量。它是一个强大的多功能工具，专门用于调试和排除网络问题，但也可以作为一个安全工具使用。\n# Example Usage\n$ tcpdump\n$ tcpdump -i &lt;interface&gt; &lt;ipaddress or hostname&gt; &lt;port&gt;\n\n其他rsync用于将文件和目录复制到目的地，类似于cp命令。但是，它也允许复制到远程位置，并且可以提供进度条，这通常用于备份\n# Example Usage\n$ rsync -vap --ignore-existing &lt;source_file&gt; &lt;destination_file&gt;\n\n#  Key flags:\nv &#x3D; verbrose\nr &#x3D; recursive\np &#x3D; preserve permissions\ng &#x3D; group\no &#x3D; owner\na &#x3D; archive\n--progress &#x3D; progresss bar\n\nscreen如果你需要在远程运行一个长时间的任务（如系统备份、ftp 传输等等），用 screen 就不用担心 SSH 会话中断而导致的任务中断了，Screen 会在断开连接的情况下继续运行你的命令！\n# Example Usage\n$ screen # 启动一个 screen 会话\n$ screen -ls # 显示正在运行中的服务\n$ screen -r # 连接会话\n\ndate# 将Unix timestamp转换为人类可读的日期形式\n$ date --date @1657252922\nFri Jul  8 12:02:02 CST 2022\n\n# 获取当前的时间戳\n$ date &quot;+%s&quot;\n1657252922\n\nsystemd# 列出所有Systemd服务\n$ systemctl -l -t service | less\n","slug":"system/Some important Linux commands","date":"2022-07-08T03:15:20.000Z","categories_index":"操作系统","tags_index":"linux","author_index":"Jx"},{"id":"c86bf2873749be4c9a292e4ee1b5c907","title":"Spring Security Note（TODO）","content":"\n\n简介Spring Security 是 Spring 家族中的一个安全管理框架。\n一般 Web 应用需要进行认证和授权\n认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户\n授权：经过认证后判断当前用户是否有权限进行某个操作\nQuick start认证（Authentication）登录校验流程解决问题思路分析登录\n自定义登录接口\n调用 ProviderManager 的方法进行认证，如果认证通过生成 JWT\n把用户信息存入 Redis 中\n\n\n自定义 UserDetailsService\n在这个类中实现列中去查询数据库\n\n\n\n校验定义 JWT 认证过滤器\n\n获取 Token\n解析 Token 获取其中的 userId\n从 Redis 中获取用户信息\n存入 SecurityContextHolder\n\n","slug":"backend/SpringSecurityNote","date":"2022-06-05T07:34:41.000Z","categories_index":"后端","tags_index":"后端","author_index":"Jx"},{"id":"635215656b0faa819fe0d4b468a19e3e","title":"转-HumanSystemOptimization","content":"\n\n\n\n\n\n\n\n\n原文: https://github.com/zijie0/HumanSystemOptimization\n背景去年 5 月曾经写了一篇文章介绍了下 Lex Fridman 大佬的日常生活安排，后续我也根据他的方法对自己的日常生活做了一系列规范和改进。这一年整体实行下来，效果还是非常显著的，本文的最后会对我的一些实践以及借助的工具做一些分享。\n最近几个月，偶然在油管上看到了个 Rich Roll 采访 Andrew Huberman 的 podcast，介绍了如何提升我们日常工作，学习表现的相关神经科学原理与可以利用的“工具”，瞬间打开了一扇新世界的大门。后续又一连追了好几集 Huberman 自己的 podcast，从各个方面了解了一下跟我们日常生活，健康，学习，工作，锻炼等方面相关的知识。与其它很多讲“养生”的文章和视频最大的区别在于，Huberman 本身是斯坦福的神经科学教授，其中讲述的内容都是来自于高质量，peer reviewed 的科学研究成果，从机体工作原理出发，非常细致地介绍了相关的实验和结论，并给出了很多实操建议（很多都是零成本，不是搞推销的……）。\n通过一系列的学习，逐渐有种学习了各种人类的“组成和操作原理”的感觉。通过一系列的工具和实践，我们也可以像调优软件程序那样来“调优”我们自身的人体系统。这篇文章就来介绍一些相关的知识内容。注意，原版的 podcast 中有非常多专业性的阐述，在这篇文章中基本都去掉了，尽量以故事性的描述来讲解，相对会比较好理解。当然准确性也会因此有所下降，如果希望获取更专业的内容，强烈建议观看 原版的 podcast 内容。\n睡眠如果你想要获得健康，更好的工作学习状态，提升生理健康如免疫，新陈代谢，以及心理健康如更好的心情，专注能力等，最最重要的前提是拥有一个良好的睡眠。\n原理睡眠最重要的控制机理是我们内在的生物钟。随着生物钟的影响，我们体内的各类化学物质会发生变化，体温也随之改变，会影响我们的各种内在状态和外在行为。Huberman 教授很形象地描述了这个“生物钟”的具体作用方式：在早上，身体释放的皮质醇（cortisol）和肾上腺素（aderenaline）会让我们醒来，同时还会设定松果体释放褪黑素的倒计时钟，会在十多个小时之后让我们感到困意再次入睡。\n影响这个生物钟的最大因素是光照。我们的眼睛除了能够看到东西，另外一个重大的作用就是通过黑视素神经节细胞来接收光照信息，用以设定我们的内在生物钟。这也是为什么有时候我们通宵工作之后，虽然已经持续很久时间没有睡眠了，但随着太阳升起，整体的生物钟被设定到了类似起床时的状态，各类化学物质的释放会让我们突然感觉又有精神了。后续很多最佳实践里也都跟这个原理相关，我们需要控制自己接收光照的时间点，类型和时长。\n此外，体温也是一个用于控制我们生物钟的手段。一般来说我们的体温会从深睡眠中比较低的状态逐渐升高，到醒来后持续上升。到了一天的后半段会开始逐渐下降，直到再次进入睡眠。\n实践基于上面的原理，Huberman 教授提供了一系列提升睡眠的最佳实践：\n\n皮质醇的释放与接触阳光有关，因此如果想尽快醒来且保持日间良好的精神状态，起床后应该到外面去接触阳光，持续 2-10 分钟。这对于血压控制，心理状态，设定睡眠的“倒计时钟”等都有很大好处。户外日光的效果最好，如果是人造光源，蓝光的效果会比较好，且最好是上部（天空的位置）的光源。根据光照强度推算，隔着窗户接收日光的强度会降低 50%以上，而达到同样效果所需要的光照时间则需要 50 到 100 倍。有意思的是，这一点对于视障人士也有效，因为前面提到的黑视素神经节细胞并不是用于视觉成像的细胞。\n对应的，在晚上要尽量减少光源的接触，因为这会扰乱我们的生物钟，让身体系统误以为是在白天。尤其是晚上 11 点到次日凌晨 4 点之间接收光源，会抑制后续几天的多巴胺的释放，影响心情，心理健康，专注度，学习能力，新陈代谢等等。关于多巴胺的作用和机理，后面会再单独介绍。\n如果不可避免需要在晚上接触光源，处于较低位置，暗淡的红光，蜡烛之类的会相对好一些。如果要看电脑，建议使用 blue blockers 眼镜，这跟一些电脑软件会自动调节屏幕色温的效果可能类似。\n傍晚观察落日，对于后续入睡也有帮助，甚至能减轻晚上摄入光照的负面影响，有点神奇。\n人一天中的精神状态一般会在中间有个短暂的低谷，所以午睡对于有些人可能是有帮助的。也可以用一些其它的非睡眠深度休息的方式来替代，如 Yoga Nidra，冥想，自我催眠（可以利用一些 App，如 Reveri）等。\n体温对生物钟周期的影响：\n早上洗冷水澡，会让人快速升温，从而把睡眠周期往前移（早起）。\n晚上锻炼身体，会让人保持高体温，从而延后周期（晚睡）。\n可以选购一些自动控制体温的智能床垫来提升睡眠质量。\n\n\n一般建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点。不过总体来看好像影响度比较小。\n饮食和药物因素：\n咖啡因会占据腺苷（adenosine）的受体，阻断入睡的信号。有不少文章都提到中午之后尽量不要喝咖啡，但 Huberman 表示没有科学实验表明咖啡因对所有人的效果是一样的，得根据自己的测试情况来。比如他自己在下午 5 点喝咖啡也能正常入睡。\n镁，对入睡有帮助。\n芹黄素也能帮助入睡，但要注意对雌性激素的影响。\n建议不要摄入太多牛磺酸。\n不建议通过摄入褪黑素来帮助入睡，褪黑素药物本身的规格把控不严格，且褪黑素容易引起抑郁情绪。\n中午可以吃低卡路里以及含酪氨酸的食物，如坚果，大豆，部分蔬菜等，提升多巴胺，肾上腺素，保持清醒。\n晚上则可以吃点淀粉，白肉等富含色氨酸的食物，进而转化为血清素，会让人更加平静，容易入睡。\n\n\n对于绝大多数人，6-8 小时的睡眠时长是比较健康的。\n对于各类药物的检索可以参考：examine.com。\n\n饮食在前面 Lex 的分享中，提到了他采取了生酮饮食以及 fasting（禁食）的习惯，这引起了我对于饮食习惯的注意。Huberman 教授正好也有几个 podcast 介绍了 fasting，肠道健康等话题，很有意思。\nFasting 的背景我们可以把身体跟进食相关的化学状态分成 2 类：\n\n吃饱了的状态，也就是血糖含量较高的状态。此时我们身体会更活跃地进行体内细胞的复制与成长。\n禁食的状态，也就是血糖含量较低的状态。此时我们的身体会更活跃地进行体内细胞的修复与清理（autophagic）。\n\n由于睡眠时我们天然是不吃东西的，所以一般来说睡眠中的一部分时间会使我们处于禁食状态，饮食时间的选择实际上就是在控制上述两个状态的持续时间和平衡关系。比较有意思的是世界上很多民族文化和宗教中，都有一些跟禁食相关的习俗，甚至会持续很多天。\n在 2012 年，科学家开始对小白鼠做实验，把他们分成两大组，一组可以在一天中的任何时间吃东西，而另一组只能在固定的 8 小时里吃东西。在大组里再区分小组，给小白鼠吃健康的和不健康的食物。结果发现，只能在 8 小时里吃东西的小白鼠们，即使吃的是不健康的高脂肪食物，他们的健康水平仍然得到了保持甚至提高，相比所有不做限制的组都有明显的提升。\n这个研究震动了学术界，后续又有非常多的针对人类，不同性别，不同年龄，不同职业（包括运动员）的各种实验与论文发表，科学家们发现这种间歇性禁食状态对于身体有非常多的好处，包括：促进肝脏健康，胆汁酸代谢，炎症自愈，保持体重，提升 brown fat 储备（对健康有益），防止非酒精性脂肪肝，血糖控制，肠道健康等等。如果养成间歇性禁食的习惯 60 天以上，还会让我们的身体倾向于代谢脂肪来供能，控制体重。\n因此，Huberman 教授指出，何时进食，与吃什么东西，其实是同等重要的。这个研究也让很多学术界的研究人员自己也都养成了 fasting 的习惯，包括 Huberman 自己。\nFasting 的实践由于长时间的禁食难度较大，所以绝大多数的研究都专注于间歇性禁食，也就是 time restricted feeding。简单来说就是跟前面的小白鼠实验一样，在一天的固定时间段来吃东西（跟睡眠周期对齐），而其它时间段都不摄入任何食物的做法。这里简单整理为基础和高阶两个版本：\n\n基础：如果想享受 fasting 的基础收益，最简单的执行原则是起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西。\n高阶：目前研究结果中最理想的进食窗口是 8 小时，结合社会习俗等，一般比较合理的时间在 10-18 点或 12-20 点的范围。看起来不吃早饭并不是什么坏事 :)\n作者特地温馨提醒，如果想通过健身来增肌，建议可以把这个时间窗口往前移，因为早上摄入蛋白质会对肌肉增长有益。而健身的时间可以自由选择。\n尽量保证这个窗口时间的稳定性，也非常重要。否则就跟频繁倒时差产生的效果差不多，会打不少收益折扣。\n如果想尝试高阶 fasting，建议逐渐切换进食习惯，例如每两天缩短 1 小时的进食窗口，逐渐达到理想的 8 小时。\n\n值得注意的是，这里说的不吃任何东西，并不是说连水也不能喝。从前面的背景可以看到，是否处于禁食状态，主要依据是血糖水平，因此：\n\n喝水，茶，咖啡（不加牛奶）等，并不会中断禁食。但一勺糖的摄入就会中断。\n晚饭后想尽快进入禁食状态，可以做一些轻量运动，比如散步等，加快血糖清理。\n二甲双胍，黄连素（berberine）等可以直接促进血糖清理。肉桂皮，柠檬汁，也能轻微降低血糖。\n\n最后，如果禁食期间觉得有些头晕，颤抖，并不需要立刻进食或摄入糖分。可以喝一点盐水（可以加柠檬汁），一般就能很好的缓解症状。这让我想起 Lex 会提到了会服用药片来补充各种电解质元素，比如钠，镁，钾等。\n饮食与消化道健康由于我个人的肠胃功能比较差，所以也特别关注了一下消化道健康的话题。Huberman 邀请了一位非常知名的微生物学家 Sonnenburg 来介绍肠胃微生物群落与我们的健康之间的关系，也是学到了很多新的知识：\n\n肠道的微生物群不仅影响消化系统的健康运作，对人体的免疫系统也起到了非常关键的因素。\n婴儿出生，成长的方式会形成非常不同的肠道菌群生态。暴露在微生物环境中（但要注意会引起疾病的情况），对于维持菌群环境是有益的，比如家里养宠物，让孩子自由玩耍等，不需要过度清洁与消毒。\n什么是健康的肠道菌群生态，目前没有一个标准的结论。不过总体来看，菌群的多样性程度高，一般就表示更加健康。\n抗生素会严重破坏肠道菌群生态，需要谨慎使用。\n\n在访谈中，两位重点讨论了一个实验，就是什么样的饮食方式会让我们更好的维持肠道菌群的多样性和健康。实验主要对比了两种附加饮食：\n\n高纤维食物：全谷类，豆类，蔬菜，坚果。这也是传统上被认为非常健康的食物，其中很多纤维的分解都需要肠道菌群的帮助，换句话说，纤维就是它们的“食物”。\n发酵类食物：酸奶，牛奶酒（kefir），康普茶，酸菜，泡菜，纳豆等。注意需要是自然发酵，一般是冷藏且非罐装的食品。而且像酸奶这类要格外注意不要加糖等添加剂。\n\n实验的结果也颇令人意外：\n\n摄入发酵类食品的组，显著提升了肠道菌群的多样性。被试者几十个免疫标志物的显著降低，对各类炎症都有更好的抑制作用。没想到吧，肠道菌群还能调节炎症。\n肠道菌群本来的多样化程度比较高的人，摄入高纤维食物是有帮助的。如果不是，则摄入高纤维食物的帮助不大。在工业化进程中，人类的进食习惯已经有很多代都转变为了摄入大量肉类，加工食品等，肠道菌群的生态无法仅通过提高纤维食物的量来改变其族群结构。\n\n此外在访谈中，两位还讨论了具体食谱推荐的问题，引用了 Christopher Gardner 关于生酮饮食与地中海饮食比较的研究。这里总结一下实践建议：\n\n如果要改善肠道菌群生态，最好的方式是一天两次摄入天然发酵类食品。\n高纤维食物对于肠道菌群生态的维护是有益的，建议日常饮食以植物类食物为主，尽量避免深度加工食品的摄入，控制糖的摄入。Sonnenburg 教授还讲了个故事，说微生物学家参加的会议，一般餐厅的沙拉吧总是会供不应求 :) 前面提到的 Rich Roll 大佬也是个素食者。\n益生菌的效果没有广泛研究支持，且这类产品的监管很有限。益生元的效果也是好坏参半，缺乏多样性，溶解速度太快等问题都使总体效果存疑。\n地中海饮食相比生酮饮食来说对健康的影响效果接近，但更容易坚持遵循。另外生酮饮食如果长期实践可能有一定的风险。所以总体更推荐地中海饮食结构。\n\n另外值得参考的是我们也有官方的 中国居民膳食指南，或许更适合东方人的饮食习惯。\n心态与动力这一部分主要介绍的是人体的多巴胺系统原理，以及如何利用它来形成健康，自律的生活方式。这一集是 Huberman 开播以来播放量最高的一集，对于强健我们的心智有着非常好的指导作用。\n原理多巴胺是一种非常重要的化学物质，主要作用于两个神经回路：一个影响身体的运动，例如帕金森病与多巴胺的分泌不足有关；另一个则影响我们的动机，欲望与快乐，这几乎与我们从事的各种活动有关，无论是工作，学习还是社交，休闲娱乐。这里我们会主要讨论多巴胺的后者影响能力。我们为什么会“放弃”，实际上是由于在不安，压力，沮丧等情绪作用下，身体内的去甲肾上腺素水平不断提升，当超过一定阈值时，神经系统中的认知控制就会关闭，我们就放弃了。多巴胺能够抑制去甲肾上腺素作用，从而持续“激励”我们前行。\n神经系统中多巴胺含量水平的高低会影响我们的情绪，当多巴胺水平低时，我们会感到情绪低落，没有动力，而多巴胺水平高时，我们会感到兴奋和快乐。在通常情况下，我们的身体处于多巴胺 baseline 的状态，当我们达成一些令人兴奋的目标（比如玩游戏胜利，考试拿高分）后，多巴胺的水平会达到一个高峰，此时我们就会获得巨大的愉悦感。在高峰之后，多巴胺水平会回落到比 baseline 更低的一个水平，且这个状态会持续一段时间。\n这里有两个非常重要的原理：\n\n多巴胺绝对值含量的高低只是一方面，更重要的是其“相对变化量”的多少。比如在刷抖音时看到了一个很有趣的视频，多巴胺水平升高，你会感到快乐，刷到下一个视频时，你感到的快乐程度好像不会那么强烈了，因为多巴胺已经在一个比较高的水平，难以形成更大的变化量。而同样的视频，如果你是几天之后看到，或许你会觉得有意思的多。所以当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高。\n多巴胺的总体“储备”是有限的！也就是说无论你是通过学习，工作，娱乐，社交，运动等不同方式来获得快乐，所消耗的“快乐货币”都是同一种：多巴胺。举几个例子来看下这个原理带来的影响：\n很多自律的人都会说自己是 work hard，play hard 的生活方式，比如工作日通过高强度的工作来获得成就和满足感，休息日进行各种休闲娱乐，运动，社交等方式来获得快乐，其实背后都是在释放多巴胺来获取快乐。长期持续，我们身体的多巴胺 baseline 会逐渐下降，出现一种耗尽（burn out）的心理感觉，对很多事物无法保持之前的兴趣与精力。\n很多人会对玩电子游戏着迷，因为它们能带来巨大的多巴胺释放刺激让人感到快乐。但要意识到，多巴胺的储备是有限的，如果对此上瘾，你的多巴胺耗尽问题就会变得非常严重：一方面能够引起你兴趣的事物会变少，可能只有玩游戏才能带来快乐；另一方面，后续甚至会导致玩游戏本身也无法触发多巴胺释放，引起严重的抑郁问题。\n\n\n\n另外，多巴胺也具有叠加效应。比如你喜欢健身，那么运动就会刺激多巴胺的释放。而我们实际去健身时，可能会不自觉地安排了很多其它的“快乐因素”，比如选一个精神状态比较好的日子，运动前喝一些能量饮料，跟认识的朋友一起去，边健身边 social，听一些自己喜欢的音乐或 podcast，等等。这些因素也都会促进多巴胺的释放，让你感到“前所未有的快乐”。但要注意前面的原理，多巴胺的高峰越高，后面随之而来持续的低谷也会越长，而且长此以往，可能会降低你单纯从运动中获取快乐的能力。这样的例子还有很多，比如边跟朋友吃饭，边玩手机，拍照发朋友圈，可以计算一下叠加了几种快乐因素 :)\n影响多巴胺的外界因素我们来看下具体影响多巴胺释放的各类因素有哪些，首先是促进多巴胺分泌的：\n\n巧克力，提升到 1.5 倍的多巴胺 baseline\n性行为，提升到 2 倍\n尼古丁，提升到 2.5 倍\n可卡因，提升到 2.5 倍\n安非他命，提升到 10 倍\n咖啡因本身只会少量提升多巴胺，但它会抑制一些多巴胺受体，提升同等多巴胺造成感受的效果\n马黛茶，包含咖啡因，能控制血糖，还能保护多巴胺神经元\n刺蒺藜豆也能提升多巴胺（基本等同于 L-DOPA），还能提升男性精子数量和质量\n运动，带有主观成分，喜欢跑步的人，可以提升到 2 倍 baseline\n健康的社交关系也会促进多巴胺释放\n\n食物方面感觉 Huberman 教授非常推荐马黛茶。\n也有很多提升多巴胺释放或影响其效果的药物：\n\nL-Tyrosine（酪氨酸），提升多巴胺\nPhenethylamine（PEA），巧克力中也包含，能够提升多巴胺\nHuperzine A，提升多巴胺\n各种“聪明药”，如 Adderall, Modafinil, Alpha-GPC, Ginkgo 等，留学党应该很多都有耳闻\n\n通常来说，不推荐持续使用这些药物，因为多巴胺释放之后的高峰会带来 baseline 水平的降低，导致无法享受活动的快乐，无法专注，限制学习能力和神经元可塑性等。Huberman 表示一周使用一次的频率应该是安全的。\n最后还有一个比较特别的研究，就是冷水浴能够提升多巴胺释放到 baseline 的 2.5 倍左右，且持续时间更长，能达到 3 小时左右。建议使用 10-14 摄氏度的水温，注意安全。此外冷水浴也不需要太频繁，每周 11 分钟左右足够。如果已经习惯了冷水浴，那么也就没有释放多巴胺的效果了。\n还有一些因素会降低多巴胺，如：\n\n褪黑素，会引起多巴胺的减少。前面也提到过并不建议使用褪黑素来帮助入睡，或者适应时差等。\n睡眠时段接触光源，也会引起接下来几天的多巴胺水平下降。半夜睡不着刷手机是很有害的哦。\n\n维持健康的多巴胺水平了解了原理和各种影响因素后，我们来看下如何有效设计我们的生活工作方式来维持健康，可持续的多巴胺水平。\n简单回顾一下，前面我们已经知道了多巴胺储备有限，且对一件事物上瘾会不断提高感受快乐的阈值，那么如何让我们能对一件事情保持长时间的兴趣和投入度，又不至于耗尽多巴胺呢？一个经典的例子是赌场的运作方式，我们并不是每一次下注都能赢，偶尔赢一次会释放多巴胺，而且根据赢得钱的多少有所上下浮动，这会吸引玩家持续参与。这就是一种非常有效的间歇性且随机的奖励机制。感觉很多游戏，社交网络产品也借鉴了这个思路来进行设计。\n对于我们经常需要从事的活动，我们也可以模拟这个机制。还记得前面提到的多巴胺叠加效应吗？我们可以通过随机化叠加因素的多少，来实现多巴胺释放的差异性。还是以健身为例，我们可以随机决定今天是否要听音乐，是否去健身时带手机，是否要在健身前喝能量饮料等因素。如果其它什么都不做，只是单纯健身，那么多巴胺的释放量就会相对较低。如此就能模拟多巴胺释放有高有低的随机奖励机制。\n成长型思维最后来看下如何构建良好的思维方式来利用多巴胺系统提升自我。\n有一个非常知名的实验，挑选了一群天生喜爱画画的小朋友，在他们完成画作后给与一些奖励。后面在移除这些奖励后，小朋友们对于画画的兴趣和动力大大降低了。这个实验说明，当我们因为一个活动收到奖励（比如金钱，美食等）时，我们反而会降低活动本身的愉悦程度。而且多巴胺本身影响我们对时间的认知，同时也影响我们的情绪状态，如果我们始终以完成活动后的奖励为目标，则整个过程中就很少释放多巴胺，让原本困难的过程变得更加难以坚持。\n仔细想一下，这是一个非常有意思的观察。多巴胺有点像我们的“本能系统”，决定了我们是否有动力做一件事。但反过来我们的主观思想却可以影响这个系统起作用的方式，这也是人类为何能摆脱动物本能，达成很多需要“反人性”的投入才能取得的成就的原因吧。上述的实验是我们的主观思想造成的一个反面作用的例子，我们自然也可以实现正面作用，那就是成长型思维。\n具体来说，就是通过自我暗示，把努力过程本身当作一种“奖励”。我在努力学习，这个过程本身就是有趣的，会让我不断变得更强，这样的想法会在过程中激发身体系统释放多巴胺，而多巴胺提升了我们的情绪和动力水平，也会让努力的过程中碰到的困难变得相对容易克服。专注于这个过程的本身，而不是在过程前进行各种外界刺激（如前面提到的药物），或者在过程后给自己巨大的奖励。\n这种思维方式看起来很主观，但这就是我们的神经系统工作的方式，虽然人类的“硬件系统”都差不多，但知识，思维这些运行之上的“软件”却可以千差万别。我们可以通过自律，自我暗示来改变自身对各类活动的喜好。例如通过暗示 fasting 对我们健康的益处，来获取满足感，而不是借助于 fasting 结束后的大快朵颐。通过自律抵御高油盐食物的吸引力，并且自我暗示植物类食物对身体的好处，坚持一段时间，会觉得花椰菜也挺美味的。这也是为什么我们在这篇文章中介绍了很多原理性的内容，而不仅仅是行为建议。因为这些原理知识能够让我们做更好的自我暗示 :)\n多巴胺系统中也有对我们认知成长造成“障碍”的运作机理。例如当我们接受到的信息支撑我们之前的信念时，也能够激发多巴胺的释放让我们感到快乐，这从本质上会改变我们对世界的认知。由此可见，“空杯心态”是多么难得的品质，网上如此多的争论无法达成共识也有很大一部分“归功”于此。如何克服神经系统中的这类缺陷呢？一种可能的方法是尽可能调节情绪，使自己处于镇静的状态（提升血清素水平），这样才能让自己更好的去倾听和吸收跟自己认知不一致的信息，更好地协同合作。\n这一节的 podcast 对我本人的冲击非常大，强烈建议大家观看这期 Mindset &amp; Drive，相信也会有不同的收获。\n学习与专注在了解了多巴胺的运作机制基础上，我们可以继续探究一些跟大脑健康，专注度，如何进行高效学习相关的话题。\n学习的原理从脑神经科学来看，学习的本质是神经元的重新连接（rewire），进一步来看，需要大脑处在一种学习的化学状态下，也就是 Huberman 经常提到的神经可塑性（neuroplasticity）状态。要达到这个神经可塑性状态，有两个重要条件，一个是足够的专注度，另外一个是“犯错”的信号（后面会展开）。另外大脑一个比较有意思的机制是，在学习时的神经可塑状态下，乙酰胆碱会标记需要改变的神经元，而具体的神经元重连接则主要是在休息和睡眠时发生，是不是有点像 JVM 虚拟机的垃圾回收机制 :)\n什么是犯错信号呢？当我们尝试做一些事情，但没有达到预期目标时，身体会给大脑发信号，“我犯错了”。处在这种犯错，沮丧的认知状态下，神经系统会释放肾上腺素（提升 alertness），乙酰胆碱（提升 focus），多巴胺（促进神经元的 change，rewire）等化学物质，激活神经元的可塑性。也就是说，犯错是我们进入学习状态的重要前提。搞机器学习的同学应该很熟悉了吧，这跟我们训练模型不是一模一样么 :) 另外很多人可能觉得心流（flow）状态是学习的最佳状态，而 Huberman 则不这么认为。心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能。\n对于这个学习状态，经典的实验是给人们戴上一些能转变角度的眼镜，然后执行一些类似物体抓取的任务。由于看到的东西通过眼镜改变了其本来的位置，一开始在尝试时总会出现抓取动作的偏离。但后续在进入神经可塑性状态后，我们能逐渐适应相关的视觉偏移，协调自己的听觉，动作等都与之协同，顺利完成任务。更有意思的是，这个“神经可塑性”的化学状态是可以持续的，我们甚至可以先通过一些其它操作触发大脑的这个机制，再去进行真正的学习，以加快学习的速度。这里还有一个隐藏逻辑，当你在遇到挫折困难时，大脑进入了可塑性状态，而此时你却放弃了，那么神经元也会重新连接到这种容易放弃的行为模式，形成恶性循环。\n人在年幼时期大脑天然的神经可塑性会比较好，而在 25 岁以后则会大大下降。我们后面会提到如何来进行克服。\n另外，休息和睡眠时也会发生大量的神经元重连接的活动，这也是之前我们就提到过的，高质量的睡眠是实现很多生理，心理健康强壮的先决条件。\n利用神经可塑性如果正在阅读文章的你还未满 25 岁，那么恭喜你，你的神经可塑性仍然非常的好，可以尽可能广泛的学习各种知识和技能。比如你可以很快学会各种乐器，新的语言，新的运动，新的专业技能等等。通过更广阔领域的体验接触，尽量找到你最有兴趣的方向，可以后续再不断深入经营。\n如果已经像我一样超过了 25 岁，那么还有很多办法来提升神经可塑性：\n\n通过实验发现，成年人对于小幅度的增量学习是完全可以适应与掌握的。例如每次视觉上的偏差只有 7 度，而不是一下子就来个 180 的大颠倒，那么成年人也能很快从错误中学习纠正。应用到实际学习中，我们每次学习的内容可以控制一下不要太多（本文有点违反了，建议收藏慢慢学习），多次积累来完成神经系统的调整学习。\n对于达成目标的渴求度越高，重要性越大，奖励的刺激越大（比如为了生存），则神经可塑性就会越容易出现。这个比较符合直觉，但是现实中可操作性可能不高。\n第三点最有意思，通过扰乱前庭神经系统（vestibular system），能够达到神经元可塑性的状态。简单来说，就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习。这一下子就让我想到了淘宝成立初期的“倒立文化”，没想到还真的有科学依据。需要注意的是，这个体验必须要新颖，也就是说如果你已经倒立很熟练了，那么去做倒立就是个日常行为，并不会给身体一种在犯错边缘，需要纠正的刺激。\n\nHuberman 认为，大脑的主要功能链路是感知，认知，情感，思想，行动。在尝试控制我们的神经系统来进行各种任务时（例如学习，解决困难问题，挑战运动极限），我们是很难用精神思想来控制其本身的（比如不断跟自己说我不能分心），更可行的办法是“逆向链路”，从我们的行动出发，利用神经系统的运作原理，逐渐影响思想，情感，认知甚至感知部分。这也是 Huberman 非常推崇各种“行动工具”的原因。Mood follows action。\n学习的理想状态除了神经可塑性的化学状态外，我们也需要注意其它的因素。例如我们不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考等。这些也都跟我们体内的多巴胺，肾上腺素，乙酰胆碱，血清素，褪黑素等化学物质的水平有关，需要做好调节。在之前 Rich Roll 的访谈节目中，Huberman 提了一个非常有效的“呼吸工具”，叫生理叹息（Physiological Sigh）。操作方法上简单来说就是吸两口气，然后出一口长气。通常情况下，只要一两次生理叹息就足以使我们的压力和警觉水平迅速下降，让人感到更加平静，提升学习表现。\n前面提到的成长型思维也很重要，在遇到错误导致的沮丧感觉时，可以不断增强自我暗示，失败是帮助我们学习成长的唯一路径，对我们是有益的，以此增加多巴胺的释放，提升学习动力和过程中的愉悦感。\n联系到睡眠对学习的促进作用，也有一些研究提供了一些相关的 tips：\n\n在学习时听一些有规律的节拍，在入睡时也播放同样的微弱节拍，能够提升学习和记忆的效果。\n一般在 90 分钟的学习后（人体生物钟的周期），可以选择进行 20 分钟的休息（non sleep deep rest），也会加强学习的效果。\nGap effect，在学习中随机停止 10 秒钟，这些停止会在睡眠中加速“播放”，提升学习效果。\n\n提升专注“专注”背后的机理是大脑中两种“网络模式”的协调，一种叫 Default network，在我们不做任何事情时被激活，另一种叫 Task networks，在我们专注于做某些事情时被激活。普通人的大脑能够很好地协调这两个模式，两者像跷跷板一样，当一种模式被激活时另一种模式会被抑制。而具有专注障碍（比如多动症）的人来说，这两者无法很好地进行协调，因此会出现无法专注的现象。\n通过提升多巴胺水平，可以有效促进这两种网络模式的协调，因此有非常多的多动症治疗药物都跟提升多巴胺有关，例如 Adderall，Modafinil 等。一些调查表明，这些药物（经常被称为聪明药，nootropics）在美国被滥用的程度甚至超过了大麻，不少“学霸”都以此来提升注意力，减少对睡眠的需求。但 Huberman 教授表示，一方面多巴胺的刺激提升后都会带来多巴胺水平的低谷，另一方面这些药物也可能导致上瘾，对新陈代谢作用造成扰动，有很多负面影响，对长期的学习与记忆效果可能并没有提升作用。在之前介绍多巴胺的章节也有提到，应该谨慎使用这类药物，并严格控制使用频率不能过高。\n最好的提升专注的方法当然是前面聊过的更好的控制我们的多巴胺系统，例如把行动跟背后的意义相连接，给自己正面的心理暗示；将任务拆成多个小的里程碑，通过过程自身的激励来促进多巴胺的释放提升我们的专注度。此外一些安全有效的提升专注力的方法包括：\n\n适量补充 Omega-3 EPA 鱼油，这是神经细胞的组成原料之一，能够有效减轻抑郁，对治疗多动症（ADHD）也有帮助。\n通过身体其它部分释放运动，可以帮助提升注意力。教授举的例子是作为神经科医生在开刀时，如果采用半蹲半站的姿态（运动释放），拿手术刀的手更稳定不容易颤抖。这让我想起以前读书时很多同学习惯转笔，现在工作了也有不少人喜欢玩指尖陀螺，或者站立办公，可能都是类似效果。\n限制视野范围，能够提升专注度。比如我们经常因为眼睛瞟到了任务栏上的消息提示闪动而分心，可以通过一些设置来进入“专注模式”。\n视线的高低也会影响神经状态，视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕。工作时一般至少把显示器放置在鼻子位置之上。\n大脑不擅长处理大量频繁的 context switch，典型的比如刷抖音，不同的信息以非常快的速度频繁切换，这对我们的注意力是有伤害作用的。2014 年的一项研究表示，我们每天在手机上花费的时间应该少于 60 分钟（青少年）/120 分钟（成年），以免引起注意力障碍问题。\n还有研究表明，17 分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力。只要做一次就可以，完全可以尝试一下。\n\n大脑健康最后来看下提升大脑健康和效能的一些方法。\n首先是前面提到过的，保证高质量的睡眠。\n运动方面，对大脑直接帮助最大的是有氧运动，提升心肺功能，支持大脑供能。建议每周 150-180 分钟的有氧训练。\n对于大脑健康有帮助的食物，其中前三点是比较重要的，后面的部分涉及的研究没有那么多：\n\nOmega3, 尤其是 EPA 等脂肪酸，是大脑组成的重要部分，且一般人都容易摄入不足。多吃鱼，牡蛎，鱼子酱，奇亚籽，核桃，大豆。一天至少摄入 1.5 克，理想情况需要 3 克以上。不喜欢吃鱼的话可以辅助摄入鱼油。\n磷脂酰丝氨酸，也对认知能力有帮助。通过鱼，肉类，卷心菜来摄入。\n乙酰胆碱，重要的神经调质，提升注意力。摄入胆碱的重要来源是鸡蛋，尤其是蛋黄。土豆，坚果，水果中也含有，虽然没有蛋黄中的含量那么丰富。可以通过 Alpha-GPC 等补充剂来获取。\n肌酸，尤其对于不吃肉的人，一天需要摄入 5 克左右。\n花青素，在蓝莓，黑莓，葡萄等食物中有提供。可以降低 DNA 损伤，缓解认知下降等问题。大约每天需要 60-120 克蓝莓的补充。\n谷氨酰胺，可以通过牛肉，鸡肉，鱼肉，鸡蛋，大豆，卷心菜，菠菜，芹菜等食物来摄取。提升大脑在缺氧（高海拔地区）下的表现，还能够抑制对糖的需求。\n水，钠，钾，镁等电解质是神经元信号传递所需的基础元素，需要保证。\n\n这一节中还讨论了我们身体对各种食物喜好进行判断的三个渠道，前两个分别是味觉判断和营养成分的下意识判断。第三个比较有意思，也跟多巴胺有关，即我们可以通过提升大脑代谢的活跃度来增加对某种食物的喜好。比如你如果不喜欢吃鱼，一种方法是你可以把鱼跟你平时爱吃的食物一起吃，另一种是给自己足够的心理暗示，说服自己吃鱼是有益身体健康的。通过这两种办法，你都可以让大脑释放多巴胺，从而逐渐提升对鱼类食物的喜好程度。\n最后，如果你对膳食补充剂感兴趣，还可以看看 Huberman 教授平时会吃的补充剂有哪些。\n长寿最后我们来看下如何延年益寿，这是 Huberman 跟这个领域的专家，来自哈佛的 David Sinclair 的一集访谈节目。\n衰老的本质Sinclair 认为，衰老是一种疾病，它本身导致了非常多通常意义上的疾病的出现，比如阿尔兹海默症，癌症等。我们可以通过科学的手段来“治疗”衰老，甚至逆转它。\n从本质上来说，衰老是基因信息的损失，这分为两部分：\n\nDNA 本身的信息，比如细胞中的 DNA 结构会在辐射等情况下受到破坏。\n控制哪些基因进行表达的信息受到了破坏，也就是所谓的表观基因组（epigenome）。这部分在衰老的因素中占了 80%。\n\n人体内有一个天然的“衰老时钟”，而且并不是以匀速走的。在年轻时我们的生长发育过程中，这个时钟走得更快。所以如果青春期发育比较迅速的人，一般来说整体的时钟走的比较快，寿命也会相对短，是不是有点吓人……而且，一般比较矮小的人，像侏儒很少会得心脏病，癌症，也会明显更长寿。不过不要紧张，前面提到了，基因本身的信息只占了衰老因素的 20%，控制基因表达这部分占了大多数。\n这里有点意外的是 Sinclair 教授介绍的最重要的几个实验，都跟前面我们提到的 fasting 有关。比如一般老鼠的寿命大概是 2 年，他们实验室有一只叫 Yoda 的老鼠，活了足足 5 年。其主要的做法就是选取了侏儒基因，以及执行 fasting。\n教授详细介绍了 fasting 为何能提升动物/人类 30% 以上的寿命：\n\n在低血糖水平时，身体会抑制哺乳动物雷帕霉素靶蛋白（mTOR），激活去乙酰化酶（sirtuin），形成一个非常良好的化学状态，清理旧蛋白质，提高胰岛素敏感度，提供更多能量，修复细胞等等。后面这个乙酰化酶是我们抵御衰老的一个重要武器。\n当胰岛素水平低时，“长寿基因”会被激活，如 SIRT1 等。\nfasting 会给细胞足够的“休息时间”。\n血糖水平低，会让身体对胰岛素更敏感，更快吸收血糖，也对健康有益。\n当你从来不感受饥饿时，你的衰老时钟也走的更快。\n除了 24 小时周期 fasting 触发的 autophagic，还有更深层次的清理机制，会在禁食第二，三天启动。在老年老鼠上的实验表明，这种长时间的禁食可以让他们延长寿命 35%。不过这个实操难度对普通人来说有点大。\n\nSinclair 也对比了一些上个世纪失败的研究，比如通过抗氧化剂来抵御衰老。现代长寿研究的核心思想是，如何通过一些机制手段来触发身体自身的衰老抵抗机制。\n此外 Sinclair 也介绍了一些激动人心的前沿技术，例如通过基因治疗方法，可以重启我们的 DNA 表达系统。通过一次注射，可以让盲人恢复视力，这已经在老鼠身上得到了验证。或许几年后，我们可以像死侍那样实现身体各部分的逆转老化。\n实践这里列出一些 Sinclair 自己的实践方式，如果想要采纳还是要结合自身的情况来看。有意思的是这集节目下有个热门留言是这个教授竟然已经 52 岁了，完全看不出来……所以你懂的。\n\n不吃早饭，午饭也吃的比较少，酸奶或者橄榄油，晚饭吃蔬菜为主，加鱼和虾，基本不吃牛排。不吃糖，甜品，面包。基本达到了 2 小时进食窗口的高阶 fasting 状态。他偶尔也会尝试一整天都不吃东西，但比较难坚持。\n每天摄入 1 克的白藜芦醇（resveratrol），1 克的 NMN（进而会转化为 NAD，which is sirtuin 的“燃料”），还有二甲双胍（metformin）。其中锻炼的日子可能会跳过一些补充品。他并不吃复合维生素。\n以蔬菜为主食的好处：富含各种营养，维生素；包含异种激素（Xenohormesis），植物基于“压力”之下产生的物质，对长寿有益。后者也可以通过槲皮素（quercetin）来做膳食补充。\n一般会隔一天进行有氧运动和力量训练。有氧运动能提升 NAD 水平。\n根据家族病史来决定一些药物摄入，如他 29 岁就开始服用降胆固醇药物。\n对于人造甜味剂，教授认为总体来说是安全的。他偶尔也会喝健怡可乐。\n\n对于这一系列实践，Sinclair 教授都进行了 10 多年的自身实验，并使用各种手段来监控身体数据。通过监控数据可以推测出一个人的“生理年龄”如何（不是光看脸），他自己在上述实践下，生理年龄在持续下降，现在已经达到了 30 岁左右的水平（实际年龄 52 岁）。另外，他认为每个人的身体情况不一样，医院约定俗成的生理指标范围也不一定适合每个人。未来这种健康数据的实时监控与个性化诊断会成为主流。他举了一些例子：\n\n监控血糖水平 HbA1c，观察 fasting 的影响等。\n监控炎症指标 CRP，与心脏病等各种疾病的诱发相关。\n监控 LDL，通过药物等进行控制。膳食胆固醇对血液胆固醇几乎没有影响，不需要戒红肉，黄油等。\n补充铁元素可能加速衰老。医学指标需要个性化，低铁元素含量并不一定导致贫血。\n\n还有一些影响寿命的负面因素：\n\n肥胖症会加速衰老。\n吸烟，会破坏基因表达，加速衰老。\nX 光检查同理，没有必要时，避免接触。\n\n展望一下 longevity 研究的未来，还是挺激动人心的。现代科学每一年能让我们的平均寿命延长 1/4 年，如果每一年能让我们的平均寿命延长超过 1 年，则达到了寿命“逃逸速度”（类比以 1000 英里每小时的速度往西飞行，太阳永远不会落下），实现了“永生”。著名的未来学家 Ray Kurzweil 预测，大约 12 年后（2034 年）就能实现，让我们拭目以待。\n除了这集 podcast，也必须附上吴承霖大佬的万星项目 程序员延寿指南。\n个人实践前面介绍的内容有点多，这篇文章篇幅也有些超了。最后来简单介绍下我个人目前采纳的一些行动和辅助工具。\n睡眠方面暂时没有什么特别的措施，现在带娃基本上晚上睡眠质量也比较一般。只是会稍稍注意一下晚上 11 点后尽量不接触手机光源。早起接收光照这点，基本上就是早上遛狗或者开车通勤时间来接触，基本压力不大。如果比较讲究的同学，还可以下一个 My Circadian Clock App 来追踪一下生物钟，也是 Satchin Panda 等大佬参与开发的项目，值得信赖。\n饮食方面，开始尝试 8 小时进食窗口的 fasting，目前感觉良好。中饭一般吃蔬菜为主的轻食，晚上就比较放飞自我，想吃啥吃啥。早上会看情况喝点盐水，茶或者 AG1 的补充剂。膳食补充剂目前基本只有复合维生素和 EPA 鱼油在使用，后面可以参考下 Huberman 的“配方” 增加一些。Huberman 自己也在节目中表示对白藜芦醇和 NMN 还在观望状态，我查了些资料发现有争议的地方还不少，所以我个人建议先采纳广受认可和使用的一些补充剂，如 EPA 鱼油，二甲双胍等。个人目前考虑的补充剂列表：\n\n基础维生素，常规补充剂。\nOmega-3 EPA。\nAG1，超火的小绿粉，各种植物提取物 + 各种维生素矿物会，Fridman，Huberman 等大佬的节目里都有提到，就是贵了点。\nBetaine HCL &amp; Pepsin，保护肠胃。\nL-Tyrosine，提升多巴胺，可能会买个尝尝鲜。\n二甲双胍，抗衰老“神药”。\nResveraCel，白藜芦醇，NR 等抗衰老组合。\n\n很多人都关心 fasting 可能引发胆结石，这里提供一些补充信息：\n\n从这篇 Bloch, H. M. 等人的论文 来看，fasting 过程中胆汁的饱和度有一个先上升后下降的过程，Dr. Berg 也以此做了解释，认为 fasting 加生酮饮食（摄入脂肪）对胆囊健康反而是有益的。\n从这篇 Sichieri, R. 等人的论文 的结果来看，long overnight fasting 和节食会提升得胆结石的概率。不过减肥（减少脂肪）本身就会提升得胆结石的概率。\n持续 24 小时以上的禁食相关的研究比较少（比较难执行），但从机理上来说长时间的禁食应该会增加得胆结石的概率。\n饮食结构，自身状况对胆结石的形成也会有很大影响，例如高胆固醇，高胰岛素水平，高碳水饮食等。高纤维食物，健康的脂肪摄入，有助于降低得胆结石的概率。\n\n总体看下来，我个人感觉这块的实验上没有一个定论（就跟 咖啡是否会引发胆结石 一样），但应该不是一个概率很大的问题，起码 Huberman 教授跟这个领域的另一位权威 Satchin Panda 教授都没有提到这块的问题。理想情况是执行 fasting 时持续对你的身体状况做医学指标的跟踪。其它就看个人选择了 :)\n工作，学习，专注方面，主要看自律了。这方面我总体控制还可以，在了解了多巴胺的工作原理之后就更加有自信了，主要靠各种软件的专注模式来近似执行番茄时钟法，此外也采用了升降桌，大概有 30% 的时间站立办公。工作间歇会尝试一下 Yoga Nidra。此外晚上学习时段会用 iPad 的 Books 来记录一下阅读时间，基本上每天保持 30 分钟以上，持续坚持。后面考虑试试工作时喝马黛茶，以及夏天开始尝试冷水澡。\n运动方面是这一年来改观最大的一项，依靠小米手环 PAI 指数功能的督促，基本上做到了每周平均 3 次的跑步或者羽毛球活动，持续把 PAI 值保持在 200 左右。总体来说对于精神状态的改观还是很大的，肚子上的脂肪也减少了很多。唯一比较困扰的是一般下班后运动都要 9，10 点开始了，结束后会离入睡的时间比较近，有时候会对睡眠质量有所影响。\n最后，Huberman 教授的 podcast 中还有很多其它内容，比如习惯养成，健身增肌，应对恐惧与创伤，情绪管理等，感兴趣的朋友可以进一步挖掘。本文以实验事实与原理假设的陈述为主，以上所有的行动方案都需要在咨询医师，专业人员的条件下，结合自身情况执行，注意自身安全，本人与 Huberman 都不负相关后果责任。\n备注：这篇文章也同时发布到了 Github，欢迎大家 Star 并提出宝贵建议，谢谢！如果你对我的其它作品感兴趣，也欢迎搜索关注公众号：RandomGenerator。\n","slug":"life/HumanSystemOptimization","date":"2022-05-31T16:46:27.000Z","categories_index":"生活","tags_index":"人生","author_index":"Jx"},{"id":"e3a0de21daf88340e00c75757650a755","title":"半个月突击 CET4 的笔记","content":"作文模板议论文（essay）\n\n\n\n\n\n\n\n\n三个段落（ 10-11 句）\n第一段（2-3 句）\n前 1-2 句提出你的问题（你对这个问题的看法是什么，好还是不好，应不应该这样做）\n第 3 句过渡句\n\n现象解释\n\n\n\n\n\n\n\n\nKeyword: Why, what\n第一句：With the rapid development of ( society / economy / education / technology / culture / medical service ), it is of great necessity for （youngsters / students / residents / citizens） to _____.\n第二句（提出问题）：\n\n It’s quite natural for us to ponder over the question ( of / that ) _____.\n我们很自然地会想到___ 这一问题\n\n观点选择\n\n\n\n\n\n\n\n\nKeyword: option choice\nNowadays (youngsters / students) have different options upon graduation. Some thinks that (  ) is beneficial, while others think (  ) is a better choice. (列举选择) Personally, I prefer the ( former / latter ). The following reasons can account for my preference.\n问题解决\n\n\n\n\n\n\n\n\nKeyword: How to, solution, measure\nIn contemporary world, (  ) （现象）. I am convinced that it is of great necessity for ( 某人 ) to ( do sth ) . (观点) How to address this problem? The following solutions can account for this issue. (过渡句)\n图画\n\n\n\n\n\n\n\n\nkeyword: image, cartoon , diagram , chart\nAs is starkly mirrored ( reflected ) in the image / chart that （一句话描述图片）it is revealed that ___ (图片内涵) . The following reasons can account for this issue. (过渡句)\n谚语As an old saying goes: _____ . For us college students, it has an increasingly important significance: ( )解释含义___ . The following reasons can account for this issue. \n第二段（6 句）通用\n3 个论点\n3 个论据\n\n第一句（论点 1）：First and formost, there is no doubt that __________ .\n首先毫无疑问的是，__________.\n第二句（论据 1）：Based on big data, a majority of ( successful social elites ) admitted that they have spent 2/3 of their time in (doing sth).\n基于大数据，大部分成功的社会精英承认，他们花了三分之二的时间做某件事\n例：基于大数据，大部分成功的学生们花了三分之二的时间练习口语\n第三句（论点 2）：Furthermore, it is obvious that  ____.\n其次，很明显的是_______.\n例：Furthermore, it is obvious that it is beneficial for students to make foreign friends.\n第四句（论据 2）Where these is/are _____ ,  there is/are _____ .\n有____ ，就有_____\n例：\n\nWhere there is a will, there is a way. 有志者，事竟成\nWhere there are foreign fridends, there is communication, therefore our speaking ability can be improved. 有外国朋友，就有交流\n\n第五句（论点 3）Last but not least, no one can deny that ____.\n最后，没有人可以否定 _____.\n第六句（论据 3）Although ____ , ____.\n尽管 ____ ，但是 ____ ,\n第三段（2 句）通用\n第一句：重申观点\n万能结尾（提出期望）\n\nIn a word, the whole society should pay close attention to the problem of (    ) . Only in this way can we have a bright and promising future.\n总之，全社会都应该关注（ ）问题，只有这样，我们才能有一个光明和充满希望的未来。\n应用文信件（Letter）通知（notice）报道（report）广告（advertisement）练习观点选择练习：2016 年下半年题目：Suppose you have two options upon graduation: one is to find a job somewhere and the other is to start a business of your own, you are to make a choice, write an essay to explain the reason.\n现象解释问题解决图片图表练习：2021 下半年四级作文题目：\nDirections：For this part，you are allowed 30 minutes to write a short essay .You should start your essay with a brief (简短) description of the picture and then express your views on protecting the forests.You should write at least 120 words but no more than 180 words\n练习：\nAt is starkly reflected in the image, a hunter was holding a gun towards a bear. it is revealed that we should protect wild animals. The following solutions can account for this issue.\nFirst and formost, there is no doubt that animals are our friends. Based on big data, a majority of successful social elites have admitted they share a harmonious relationships with animals.Further more, it is obvious that killing is cruel. where there is no buying, there is no killing. Last but not least, no one can deny that there are benefits on genes of wild life.  Though we can’t take advantage of them all for now, the potentials will buried if we kill them all.\nIn a word, the whole society should pay close attention to the problem of animal protection. Only in this way can we have a bright and promising future.\n高频单词\n\n\n\n\n\n\n\n\n以下高频词出自 https://www.bilibili.com/video/BV17w411Z7Wz ，配合浏览器插件 Relingo 食用。每天快速地把所有单词过 2-3 遍。\n\nconsumer\nsocial\nproduct\nlikely\nsystem\nactivity\nreward\nstress*\nexpert*\nconcern*\nuniversity\nindividual*\nview\nopportunity*\nhunt\nchallenge\nprocess\nproject\namount\nability\nrate\nradiation*\nfeature\nenvironment\ncreate\ncrash\nadvertise*\ntend*\nstatus\nreader\nper\nlocal\nhighway\nbrand*\nassume*\nphysical*\ninstant*\nfocus\nfashion\nexpand\neffective\ndeclare\nbenefit*\nadult*\naffect\ncompete\nglobal\npolicy\naccount\nfoundation*\ninvolve*\ntechnology\ncompetition\nbehavior\ncommunity\nrange\nmaintain\naction\nobvious*\nprimarily\nappeal*\ndetail\ndecade\npollution\nadvantage*\nculture*\nautobiography*\nleader\naccordingly*\nplastic*\napprove*\nperformance\nrecognize*\nfactor*\nenormous*\navoid*\nshift\nsource\nfulfill*\nmoral*\nrank\nreplace\ncomplex\ninjury*\noutcome\ninsurance*\nimpression*\nhousehold*\nclaim*\npersonality*\npersonnel*\nemployee\nreserve\napproach*\ncapacity*\ngenerally*\nautomobile\nmale\nregardless*\ncontact\nwealthy*\nestimate*\nincident*\ndevice\nerror\nrelationship\nrecently\nscale\nunion\nclimate*\navaliable\ncriticism*\ndiet*\ncivilian*\nground\nliberal*\nestablish*\nindicate\naccomplish\nfinally\nspot*\npotential*\nprofessional*\nideal\nreflect\nconsiderable*\ninfluence\ntrace\nattitude\nchemical\nnetwork\npositive\nterritory*\nengage*\nwitness*\nwelfare*\ncareer\nattach*\nprofit\nmusician\npurchase\ncompetitive\nparticularly*\nassign\nresponse\npace*\ncomplaint\nidentify\narise\nvictim*\nsample\nmodify\nproperty\nstructure\ntarget\nbelief\nminority*\nresistant*\ntheory*\nsignal*\nbloom*\ncheat\ninstance\ntransfer\nthreaten*\nabroad\naudience\nscan\ncorporation\nthreat*\ngas*\npromote\nindustrial*\nstyle\ngrant\napply\nextend\ninstall\nimpact\nfunction\nuser\npropose*\nalter\nagency*\ncontribute\neducate\nabsent*\npoison*\nairline\npossibility\nflash\nnuclear*\nnucleus*\nraw\nextensive\nmilitary*\ndirectly\ndeny\nabsorb*\ncommittee\ncomplain*\naid\nprotein*\nstatement\ninstitution*\nroute\nassociate*\ngrowth\nconvince*\nliberate*\ncell\npublish\nyoungster\nfailure\nfaint*\nrob*\nresident*\nfund*\nappearance\nportable\nefficient\npreference\nsolution\nconfidence*\ntreatment*\nadopt*\nskilled\ncultivate*\nrespond\nvary*\nexit\nsurvey*\nlest*\nvehicle\nconstant\nspeaker\natmosphere*\nlatter\nreform*\neconomy*\nprimary\ndiffer\ncapable\ndistinct*\ndefine\nresist*\nargument\ntransform\ndespite*\nstrengthen*\ndistinguish*\nemotional\ndata\nachievement*\nstrategy*\nsufficient*\nban\npoverty*\nwage*\nwisdom*\nassemble*\npredict\naccurate*\nadapt*\nrisk*\nliquid*\nthunder*\nvirtue*\nfemale\nrecommend\nequality\neconomic*\neconomics*\nemit\nbar\narrange*\nconference*\nimprovement*\nprevious\nsensible*\nexchange\nconsumption*\nintelligence*\ndebate*\ncriticize*\nrail*\nreveal\nspray*\ninvestment*\nreinforce*\ncope*\nexceed*\nconfuse*\naware*\nsuperior\nemphasize\nregion\npop\nintensity*\nappreciate*\ncolleague*\ntransportation\neveryday\nfame*\nfamiliar*\nurban*\nspan\nessential*\ninhabitant*\nweapon\naccumulate*\neliminate*\nremarkable*\nremedy*\nmislead*\nwhale*\ncliff*\ndiscard*\naspect*\nshortage\nmobile\ncrime*\nrelax\nfleet*\ndisplay\nmask*\nreverse\nsecurity\nemphasis*\nlucky\nsignificant*\naircraft*\ncease*\ntransmit\ngasoline*\nconduct*\nabandon\nstimulate*\nbind\npressure*\ncharacterize*\ncycle\nenable\ncraft*\nconsist*\nvital*\npowerful\nnavy*\nauthority\nshrink*\nrid\nsurround*\nalike*\narouse*\nexcessive*\ndispute*\nbehave\nelectrical\nhighly\nselect\ncontrast\ninfant\nathlete*\noverseas*\nelevator*\napart\nreality*\ncommitment*\ngaze*\ntough*\nexpense\nsensitive*\nanxiety*\nevidence*\nimage\njournal\ndelivery\ncommit\nadvertisement*\ncoordinate*\nurgent*\ntalent*\npeculiar*\nhandle\nhandsome\nrepresent\nexception\nspecific*\nbalance\nindoor\nrelease\nincreasingly\nreputation*\nforbid*\ninspire*\nusage\ndistress*\ncommunicate*\nappoint*\nreaction\nsalad\ninternal\nprior*\ngenerous*\nfundamental*\nversion\nappointment*\ndefinite*\ncabinet*\naluminum*\nalways\nitem\ncode\nprosperity*\nresponsibility*\nanalyze\ninterfere\ngenerate\nequip\nworldwide\nmission*\nspecialize*\nemployment\nswitch\nobserve*\nnegative\ninvention*\nhumor*\ninferior*\ntypical\ncommand\nconfirm\nintelligent\nlabel\npigeon*\nancient*\nslight*\ndomestic*\nvacant*\nconvert\nforth\nrelate\ndisturb*\nengine\nslice*\nnavigation\nelectronic\nelectronics\nparliament*\nnecessarily\nemerge*\nnumerous\ngenuine*\nconstruct\nannoy*\ncharacter\nstrain*\nobtain\nnecessity\nproportion*\nloyalty*\nlubricate*\ninsert\nviolence\nnaturally\nexport\ntender*\nabsence*\nclassify*\nmood*\ncrisis*\ncomprehension*\ndiscipline*\ntax\ninfluential*\ninform*\noriginal*\nmanagement\nreluctant*\nhousewife\nexpose*\nentitle*\nenvy*\ntendency*\ncommission\nregister\nmedia\ncounty*\nreproduce\nneighborhood*\ndisposal*\ncuriosity*\npassive*\ngap\ndump\nrarely*\nsuggestion\nlocate\ninteraction*\nundoubtedly\nsomewhat*\nsum\nrack*\ntransmission*\nexternal\ncrack*\nconvenience*\nadequate*\nvolunteer*\nphenomenon*\ncomparison*\ntypewriter\nchannel\nsophisticated*\nconclude*\nsection\nparticipate*\ndepression*\nqueue\nvice*\nlaunch\nmanner*\nexhaust*\nundertake*\nmotivate*\nproposal*\ntremendous*\nperspective*\naggressive*\nacademic*\nlag*\napplication\ndistribute*\ncontrary*\ncomprise*\nelement\nunlike\nmostly*\nmotel*\nbackground\nvisual\nrefine*\nresponsible*\npetroleum*\nlegal*\ncivilization*\npump*\nquote*\noutward*\ndecrease\nfatal*\naccuse*\naccustomed*\nobjective*\nconservation*\noptical*\ndelicate*\nmechanic*\nmechanics*\nscholarship*\ncarpenter*\nfluent*\nswallow*\nepisode*\nattraction*\norbit*\nmixture\nscreen\nadministration\nabuse*\nomit*\naccommodation*\nacceptance*\nconflict*\nsoda\nscheme\nconservative*\nattribute\nleisure*\nretire\nmere*\ncomment\nsalary\npreserve*\noverall*\nensure\nimpose*\nunfortunately*\nevolution*\naccess\nidentical*\njoint*\nintention*\nfee\ndebt\nadvisable*\nsequence\ncourt*\nintroduction\ncompetent*\nfederal*\ntemper*\npercentage*\nconsiderate*\nillegal\nlargely*\nintellectual\nsenior*\nmature*\ninterval\ngrasp*\noutput\ndrum*\ncautious*\nrude*\nelect*\nstir*\ninsight*\ndurable*\nhorizontal*\nhorn*\nphilosophy*\nappropriate*\nfaulty*\ngenius*\ndownward*\nexecutive*\nsurplus*\nlibrarian*\nstretch*\nhandy*\ndeliberate*\ncapture*\nphrase*\nalternative*\naward\nincline*\ncancer*\ncollection\nglimpse*\ndemonstrate*\nskim*\ninstruct*\nconstitution*\nmanufacture*\ndrama*\nrelief*\nagent\ntrail*\nconnection\nmill*\ncommander*\nhandful*\nmedium*\nleadership\ncreature*\ninstrument*\nsubstitute*\nchin*\nsteady*\nspecialist*\nadjust*\nenforce*\norgan*\ngrocer*\ncreep*\ncooperate*\nsympathetic*\nstorage\ndepart*\nrender*\nprivilege*\nteenager*\ncontribution\nfeedback*\nacquisition*\nexistence*\nexplore\nwax*\nmess*\nprince*\ngenerator*\nfatigue*\naccompany*\nrural*\nhoney\nattain*\nbillion\nuncover*\nlocomotive*\ntrap*\nassociation*\nspite*\ninterview\npessimistic*\nbark*\ndevil*\nuniverse*\nreduction*\npsychological*\ninvade*\nidentity*\npermanent*\nscrew*\ninterpretation*\neditor\nguarantee*\nclassic*\npose*\ndelegate*\nartificial*\ncassette*\nromantic*\nannual*\napartment*\ndeposit*\nfantasy*\nmud*\nauthor\nassure*\ncorrespond*\noutlet*\ntopic\nrival*\ninitiative*\nslide*\nextreme\nmisunderstand\nevident*\ncasual*\nroutine*\ntrumpet*\nancestor*\nstaff*\nnotion*\ncounter\nfabric*\noccasion*\nlump*\nhopeless*\ndocument\nprecaution*\nintend*\ncash*\nhardware\ntidy\nresolve\nprotective*\nquit\nsevere*\nextension\ntrial*\nexpectation\ntelescope*\npassport\nexploit*\ndemocracy*\nrequirement\nfile\nneglect*\nexaggerate*\nthirst*\novernight*\nplot\nestate*\nliter*\nvariation*\ncopper*\ndevise*\nprinciple*\nsportsman*\ncreative\nformer*\nunity*\nsimilarly*\nassumption*\nreception*\n\nEnding","slug":"english/CET4","date":"2022-05-25T09:59:41.000Z","categories_index":"英语","tags_index":"英语,笔记","author_index":"Jx"},{"id":"a5751cb68211f766011de586416700ec","title":"各种数据范围下的算法选择","content":"\n\n\n\n\n数据范围\n时间复杂度\n算法\n\n\n\n\n\nDFS+剪枝，状态压缩 DP\n\n\n\n\nDP，Floyd，高斯消元\n\n\n\n, \nDP，二分，朴素版 Dijkstra、朴素版 Prim、Bellman-Ford\n\n\n\n\n块状链表、分块、莫队\n\n\n\n\nSort、线段树、树状数组、Set、Map、Heap、拓扑排序、Dijkstra+Heap、Prim+Heap、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ 分治、整体二分、后缀数组、树链剖分、动态树\n\n\n\n常数较小的\n单调队列、Hash、双指针扫描、并查集、KMP、AC 自动机、Sort、树状数组、Heap、Dijkstra、SPFA\n\n\n\n\n双指针扫描、KMP、AC自动机、线性筛素数\n\n\n\n\n判断质数\n\n\n\n\n最大公约数、快速幂、数位 DP\n\n\n\n\n高精度加减乘除\n\n\n\n\nk 表示数位、高精度加减、FFT/NTT\n\n\n","slug":"algorithm/根据数据范围反推算法","date":"2022-04-08T02:43:04.000Z","categories_index":"算法","tags_index":"算法,技巧","author_index":"Jx"},{"id":"da2d8763fa18b31af06ba8fb8f150918","title":"PTA-L3-003 社交集群(30 分)","content":"\n\n\n\n\n\n\n\n\n\n\n题目链接：PTA-L3-003 社交集群(30 分)\n题目背景当你在社交网络平台注册时，一般总是被要求填写你的个人兴趣爱好，以便找到具有相同兴趣爱好的潜在的朋友。一个“社交集群”是指部分兴趣爱好相同的人的集合。你需要找出所有的社交集群。\n输入格式输入在第一行给出一个正整数 ，为社交网络平台注册的所有用户的人数。于是这些人从  到  编号。随后  行，每行按以下格式给出一个人的兴趣爱好列表：\n\n其中是兴趣爱好的个数，是第个兴趣爱好的编号，为区间  内的整数。\n输出格式首先在一行中输出不同的社交集群的个数。随后第二行按非增序输出每个集群中的人数。数字间以一个空格分隔，行末不得有多余空格。\n输入样例8\n3: 2 7 10\n1: 4\n2: 5 3\n1: 4\n1: 3\n1: 4\n4: 6 8 1 5\n1: 4\n\n输出样例3\n4 3 1\n\n解题思路\n题目的大致意思就是，一个人可以有多个兴趣爱好，而拥有共同兴趣爱好的人可以组成一个圈子，你要找出一共有多少个圈子，以及圈子有多少人。看到这种需要进行元素分组管理的问题，我们考虑使用并查集去维护。\n因为要统计圈子的人数，我们需要开两个数组，一个数组  维护兴趣爱好的分组，一个数组  用于存放各个分组的人数。对于每个人的多个兴趣爱好 ，我们将第  合并(merge)入  形成一个圈子（分组），也就是将  视为一个头节点，然后根据这个头节点 去更新圈子的人数，更新人数的时候需要去找到  的祖先节点，对祖先节点的人数进行更新，即 ;\n最后统计一波人数即可，有一点细节要注意的是，最后的输出不能有空格！不然爆 0\n完整代码import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    private static int[] a;\n\n    private static final int MAX = 1010;\n\n    public static void main(String[] args) throws IOException {\n        int n = Integer.parseInt(br.readLine());\n        \n        // nums 用于统计人数\n        int[] nums = new int[MAX];\n\n        // 初始化并查集\n        a = new int[MAX];\n        for (int i = 1; i &lt; a.length; i++) {\n            a[i] = i;\n        }\n\n        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n        for (int i = 1; i &lt;= n; i++) {\n            String[] s = br.readLine().split(\" \");\n            int first = Integer.parseInt(s[1]);\n            \n            // 增加人数\n            nums[find(first)]++;\n            \n            set.add(first);\n            for (int j = 2; j &lt; s.length; j++) {\n                int h = Integer.parseInt(s[j]);\n                set.add(h);\n                // 将后面的全部并入第一个\n                merge(h, first);\n            }\n        }\n\n        // 统计集群人数\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 1; i &lt; a.length; i++) {\n            if (set.contains(i)) {\n                int ii = find(i);\n                if (ii == i) {\n                    if (map.containsKey(i)) {\n                        map.put(i, map.get(i) + nums[i]);\n                    } else {\n                        map.put(i, nums[i]);\n                    }\n                } else {\n                    if (map.containsKey(ii)) {\n                        map.put(ii, map.get(ii) + nums[i]);\n                    } else {\n                        map.put(ii, nums[i]);\n                    }\n                }\n            }\n        }\n        // out\n        pw.println(map.size());\n        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(map.values());\n        // 逆序排序\n        ans.sort(Collections.reverseOrder());\n        int i;\n        for (i = 0; i &lt; ans.size() - 1; i++) {\n            pw.print(ans.get(i) + \" \");\n        }\n        pw.print(ans.get(i));\n        pw.flush();\n    }\n\n    private static void merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            a[x] = y;\n        }\n    }\n\n    private static int find(int x) {\n        if (x != a[x]) {\n            a[x] = find(a[x]);\n        }\n        return a[x];\n    }\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    private static PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n\n}\n\n\n","slug":"algorithm/PTA-L3-003","date":"2022-04-05T08:00:41.000Z","categories_index":"算法","tags_index":"并查集,题解","author_index":"Jx"},{"id":"2fb6f73465144858123c433ce6781558","title":"矩阵快速幂","content":"\n\n\n引例（洛谷P3390）题目描述给定一个的矩阵，求。\n输入格式第一行两个整数  接下来  行，每行  个整数，第  行的第  的数表示 。\n输出格式输出\n共 行，每行  个数，第  行第  个数表示 ，每个元素对取模。\n输入输出样例输入 #12 1\n1 1\n1 1\n\n输出 #11 1\n1 1\n\n数据范围对于 % 的数据：\n完整代码import java.io.*;\n\n/**\n * P3390 【模板】矩阵快速幂\n */\n@SuppressWarnings(\"all\")\npublic class P3390 {\n\n    private static long[][] matrix;\n\n    private static int n;\n\n    private static long k;\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) throws Exception {\n        n = nextInt();\n        k = nextLong();\n        matrix = new long[n][n];\n        for (int i = 0; i &lt; matrix.length; i++) {\n            for (int j = 0; j &lt; matrix[i].length; j++) {\n                matrix[i][j] = nextInt();\n            }\n        }\n        \n        long[][] ans = quickPow(k);\n        for (int i = 0; i &lt; ans.length; i++) {\n            for (int j = 0; j &lt; ans[i].length; j++) {\n                pw.print(ans[i][j] + \" \");\n            }\n            pw.println();\n        }\n        \n        pw.flush();\n    }\n\n    private static long[][] quickPow(long k) throws Exception {\n        long[][] res = new long[n][n];\n        // 单位矩阵\n        for (int i = 0; i &lt; n; i++) {\n            res[i][i] = 1;\n        }\n        while (k &gt; 0) {\n            if ((k &amp; 1) &gt; 0) {\n                res = matrixMultiplication(res, matrix);\n            }\n            k &gt;&gt;= 1;\n            matrix = matrixMultiplication(matrix, matrix);\n        }\n        return res;\n    }\n\n    private static long[][] matrixMultiplication(long[][] A, long[][] B) throws Exception {\n        int rowA = A.length, columnA = A[0].length, rowB = B.length, columnB = B[0].length;\n        if (columnA != rowB) {\n            throw new Exception(\"第一个矩阵的列数必须等于第二个矩阵的行数！\");\n        }\n        long[][] C = new long[rowA][columnB];\n        for (int i = 0; i &lt; rowA; i++) {\n            for (int j = 0; j &lt; columnB; j++) {\n                for (int k = 0; k &lt; columnA; k++) {\n                    C[i][j] += A[i][k] * B[k][j];\n                    C[i][j] %= MOD;\n                }\n            }\n        }\n        return C;\n    }\n\n    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    private static StreamTokenizer st = new StreamTokenizer(br);\n\n    private static PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n\n    private static int nextInt() throws IOException {\n        st.nextToken();\n        return (int) st.nval;\n    }\n\n    private static long nextLong() throws IOException {\n        st.nextToken();\n        return (long) st.nval;\n    }\n\n}\n\n\n","slug":"algorithm/矩阵快速幂","date":"2022-03-28T08:00:41.000Z","categories_index":"算法","tags_index":"算法,矩阵,快速幂","author_index":"Jx"},{"id":"b6bea84273156013b3326c84401baf8a","title":"一文搞懂树状数组","content":"\n\n介绍树状数组是由Peter M. Fenwick提出的二叉索引树（Binary Indexed Trees）结构，最初用于数据压缩。在算法竞赛中，常用于区间操作。\n类似的数据结构还有线段树，线段树可以实现树状数组所有的操作，甚至更多。而树状数组代码简洁，运行速度也线段树快，占用内存空间也比线段树少，如果是一个单点修改的问题，树状数组绝对是一个不二选择。\n接下来我们引入一个问题：\n\n\n\n\n\n\n\n\n\n 已知有  个箱子 ，你需要进行以下两种操作：\n\n将  个大理石放入第  箱子中\n求第  到  个箱子中大理石总共有多少个\n\n假设我们要进行  次操作。\n对于这个问题，很容易想到朴素的做法：直接修改数组、遍历求和。\n朴素做法对于操作 1 的时间复杂度为：。操作 2 时间复杂度为：。当所有操作都为 2 的时候，达到最坏时间复杂度  。\n如果数据量大的话，使用朴素的做法显然会 。\n这是道简单的单点修改 &amp; 区间查询的题目，我们使用树状数组，查询的时间复杂度就可以降到，最坏时间复杂度就可以降到 了。\n原理下图为树状数组的原理：\n\n是不是看起来非常抽象？完全无法理解其中是什么含义？是的就是非常的抽象，让我来解释一下这张图你就明白了~\n树状数组的结构和线段树很类似，都是用一个大的节点去管理若干个小节点，查询的时候只需要查大节点就可以得到区间的信息。\n图中 8 个蓝色的方块代表着数组 ，而绿色方块代表数组  ，即管理着数组  的逻辑结构，为什么叫逻辑结构呢，我的理解是这个结构是根据逻辑虚构出来的，在实际内存中并不存在数组 ，而图中的  则是将抽象的逻辑结构形象化了，有助于去理解数据结构。可以从图中看出：\n\n 管理的是 \n\n 管理的是 \n\n 管理的是 \n\n 管理的是 \n\n\n以 t[6] 为例，方块的下半部分是数组索引的二进制表示形式，而高亮部分的位（10）就是 lowbit。我们可以发现，lowbit 的值就是结点的覆盖长度，6的  值为 2，那么就可以得知t[6]结点的覆盖长度为 2。知道了覆盖长度，我们就可以利用覆盖长度来找上一个结点或下一个结点（父结点）了。\n比如我们要找 t[6] 的父结点 t[8]，只需要t[6+lowbit(6)]就行了，由此我们可以得出:  的父节点为 。\n那如果要找 t[6] 的上一个结点 t[4] 呢？也很简单，和找父结点类似，索引值减去 lowbit 的值就可以了，也就是t[6-lowbit(6)]，由此我们可以得出:   的上一个结点为 。\n好了，知道了怎么找到上一个结点和父结点，那么我们就可以正式开始搞树状数组了~\n等等，到这里你一定很懵逼，上面说的  到底是啥玩意？那怎么去求  呢？那么在正式开搞树状数组前，我们先详细的讲讲运算~\nlowbit运算为了简洁起见，我们定义”“为非负整数中最小的非零有效位，即非负整数在二进制表示下最低位 1 及其后面的 0 构成的数值。\n例如，我们对十进制数字 44 进行  运算：。\n其中就是最低位 1 及其后面的 0 构成的数值。\n但怎么通过程序去找到所谓的  数值呢？转成二进制再通过遍历寻找？这显然效率太低，不妨我们用位运算试试吧~\n\n首先我们知道44的二进制为 101100，即。\n将 101100 按位取反，得到 010011，再将取反后的值 + 1，得到 010100。\n观察101100 和 010100，可以看出，除了最低位的 1 和后面的 0，其余位上两者均不同。这时聪明的你可能已经发现了，将两者进行按位与运算不就可以得到lowbit了吗？没错，就是这样的~\n\n简言之，就是将该二进制值 和 该二进制取反后+1 的值 进行按位与运算，就可以得到 lowbit 值了，即：\n\n众所周知，正数和 0 的补码是数字本身，而负数的补码则是将其对应正数按位取反再加 1。因为在常见计算机中存储使用的是补码，取反加一后的值就是负的这个数，所以 lowbit 的值为 n&amp;-n，即最终为：\n\n代码如下：\n// Java\npublic int lowbit(int n) {\n  \treturn n &amp; -n;\n}\n\n\n\n单点修改 &amp; 区间查询单点修改单点修改我们只需要将  加上 , 更新  所有的上级（父结点）即可。\n例如对 ，具体过程如下图\n\n代码如下：\n// Java\npublic void add(int i, int k) {\n  \twhile(i &lt;= n) {\n      \ta[i] += k;\n      \ti += lowbit(i);\n    }\n}\n\n区间查询想要在单点修改中进行区间查询，首先要知道怎么求  的前缀和。\n还是利用  函数，一直找上一个结点进行求和。\n例如求  前缀和，过程如下图：\n\n知道了怎么求前缀和后，求区间就很简单了，只需要将两个前缀和相减，即：\n\n例如求区间和，过程如下图：\n\n代码如下：\n// Java\npublic int getPrefixSum(int i) {\n  \tint sum = 0;\n  \twhile(i &gt; 0) {\n      \tsum += a[i];\n      \ti -= lowbit(i);\n    }\n  \treturn sum;\n}\n\npublic int getSum(int l, int r) {\n  \treturn getPrefixSum(r) - getPrefixSum(l - 1);\n}\n\n区间修改 &amp; 单点查询区间修改代码如下：\n// Java\n\n单点查询代码如下：\n// Java\n\n区间修改 &amp; 区间查询区间修改代码如下：\n// Java\n\n区间查询代码如下：\n// Java\n\n练习题\nLuoguP3374【模板】树状数组 1(单点修改 &amp; 区间查询)\nLuoguP3368【模板】树状数组 2(区间修改 &amp; 单点查询)\n\n参考\nhttps://www.bilibili.com/video/BV1pE41197Qj\nhttps://oi-wiki.org/ds/fenwick/\nhttps://www.topcoder.com/thrive/articles/Binary%20Indexed%20Trees\n\n","slug":"data-structure/binary-indexed-tree","date":"2022-02-17T10:00:41.000Z","categories_index":"数据结构","tags_index":"树状数组,数据结构","author_index":"Jx"},{"id":"b6831801f35d47f9ac7cc7cf693ccf65","title":"CSS 常用属性总结","content":"\n\n\n\n\n\n\n\n\n下表为平时常用的 CSS 属性\n\n\n\n属性\n描述\n可选值\n\n\n\ncolor\n元素颜色，一般用于设置字体颜色\n\n\n\nbackground-color\n背景颜色\n\n\n\nbackground-image\n设置背景图片\n\n\n\ndisplay\n元素的显示类型\n&#123;block, inline-block, inline, none, flex ...&#125;\n\n\nwidth\n元素的宽度\n\n\n\nheight\n元素的高度\n\n\n\nmin-width\n最小宽度\n\n\n\nmin-height\n最小高度\n\n\n\nmax-width\n最大宽度\n\n\n\nmax-height\n最大高度\n\n\n\nmargin\n外边距\n\n\n\npadding\n内边距\n\n\n\nborder\n边界属性\n\n\n\nborder-color\n边框颜色\n\n\n\nborder-width\n盒子模型的边框宽度\n\n\n\nborder-style\n边框样式\n&#123;none, solid, dotted, inset, dashed solid ...&#125;\n\n\nborder-radius\n外边框圆角\n\n\n\nfont\n字体属性\n\n\n\nfont-family\n定义字体\n\n\n\nfont-style\n字体样式\n&#123;normal, italic, oblique&#125;\n\n\nfont-weight\n字体厚度（用于加粗）\n&#123;normal, bold, lighter, bolder&#125;\n\n\nposition\n用于元素的定位\n&#123;static, relative, absolute, fixed, sticky&#125;\n\n\nz-index\n设置重叠元素的顺序\n&#123;auto, -1, 0, 1, 2, 3 ...&#125;\n\n\noverflow\n元素内容溢出属性\n&#123;visible, hidden, scroll, auto ...&#125;\n\n\ncursor\n指定当鼠标指向元素时，展示不同的游标\n&#123;default, pointer, wait, help, progress, not-allowed ...&#125;\n\n\nopactity\n元素的不透明度、透明度\n0.0-1.0\n\n\n","slug":"frontend/CSS 常用代码总结","date":"2022-02-13T05:50:41.000Z","categories_index":"前端","tags_index":"前端,CSS","author_index":"Jx"},{"id":"62bc8025e0eb197d420ffa98bc79c161","title":"git 常用命令","content":"仓库# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n\n增加/删除文件# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n代码提交# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n分支# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote&#x2F;branch]\n\n标签# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs&#x2F;tags&#x2F;[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n查看信息# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty&#x3D;format:%s\n\n# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n远程同步# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n撤销# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n其他# 生成一个可供发布的压缩包\n$ git archive\n","slug":"tools/git常用命令","date":"2022-01-28T17:00:41.000Z","categories_index":"常用工具","tags_index":"git,汇总","author_index":"Jx"},{"id":"091c0ae76037fb4e10221116ffff5b42","title":"2022广东普通专升本考纲(计算机)","content":"\n\n一、政治理论考试范围马克思主义中国化的历史进程与理论成果；毛泽东思想及其历史地位；新民主主义革命理论；社会主义改造理论；社会主义建设道路初步探索的理论成果；邓小平理论；“三个代表〞重要思想；科学发展观；习近平新时代中国特色社会主义思想及其历史地位；坚持和发展中国特色社会主义的总任务；“五位一体”总体布局；“四个全面〞战略布局；实现中华民族伟大复兴的重要保障；中国特色大国外交；坚持和加强党的领导；时事政治(2021年1月1日至2021年12月31日国内外重大时事政治及中国共产党和中国政府在现阶段的基本路线利重大方针政策）。\n参考书目\n马克思主义理论研究和建设工程重点教材：《毛泽东思想和中国特色社会主义理论体系概论》，北京：高等教育出版社，2021年。\n\n二、英语考试范围1. 词汇认知 3400 个英语单词以及由这些词构成的常用词组【详见《高职高专教育英语课程教学基本要求（试行）》附表四词汇表]，能够按照基本构词法识别生词，并具备在语篇中理解和运用词汇的能力。\n2. 语法掌握基本的英语语法规则【详见《高职高专教育英语课程教学基本要求（试行）》附表三语法结构表〕，具备在语篇中正确运用所学语法知识的能力。\n3. 阅读能读懂书、报、杂志中难度中等的一般性话题的简短文段以及信函、技术说明书、合同等简短的实用文字材料。对所读材料能够（1）理解主旨要义；（2）理解文中具体信息;（3）根据上下文推断单词和短语的含义；（4）做出判断和推理；（5）理解文章的基本结构；（6）理解作者的意图、观点和态度；（7）快速查找相关信息。\n4. 写作能根据所给的提示，用英语写一篇约100个单词的简短应用文。要求格式规范，内容切题，条理清晰，语法正确，表达得体。\n参考书目\n教育部高等教育司编：《高职高专教育英语课程教学基本要求（试行）》，北京：高等教育出版社，2006年。\n\n三、高等数学考试范围1. 函数与极限映射与函数，数列的极限，两数的极限，无穷小与无穷大，极限运算法则，极限存在准则、两个重要极限，无穷小的比较，两数的连续性与间断点，连续函数的运算与初等函数的连续性，闭区间上连续两数的性质\n2. 导数与微分导数概念，两数的求导法则，高阶导数，隐两数及由参数方程所确定的函数的导数相关变化率，两数的微分．\n3. 微分中值定理与导数的应用微分中值定理，洛必达法则，泰勒公式，函数的单调性与曲线的凹凸性，函数的极值与最大值最小值，函数图形的描绘，曲率，方程的近似解.\n4. 不定积分不定积分的概念与性质，换元积分法，分部积分法，有理函数的积分，积分表的使用\n5. 定积分及应用定积分的概念与性质，微积分基本公式，定积分的换元法和分部积分法，反常积分，定积分的元素法，定积分在几何学上的应用，定积分在物理学上的应用.\n6. 常微分方程微分方程的基本概念，可分离变量的微分方程，一阶线性微分方程，常系数齐次线性微分方程\n7. 多元函数微分法及其应用多元两数的基本概念，偏导数，全微分，多元复合函数的求导法则，隐函数的求导公式\n8. 重积分二重积分的概念与性质，二重积分的计算法，三重积分，重积分的应用。\n9. 无穷级数常数项级数的概念和性质，常数项级数的审敛法\n参考书目\n同济大学数学系铺：《高等数学》（第七版）（上、下册)，北京：高等教育出版社， 2014年.\n\n\n赵树塬主编：《微积分》（第四版）[ 经济应用数学基础（一）]，北京：中国人民大学出版社，2016年.\n\n四、计算机基础与程序设计考试范围一、程序设计与C语言\n二、数据的存储与运算\n三、顺序程序设计\n四、选择结构程序设计\n五、循环结构程序设计\n六、利用数组处理批量数据\n七、用函数实现模块化程序设计\n八、指针\n九、使用结构体类型处理組合数据\n十、利用文件保存数据\n十一、数据结构引论\n十二、线性表\n十三、栈\n十四、队列\n十五、算法及复杂度\n十六、树\n十七、散列表\n十八、优先队列\n十九、排序算法\n二十、图\n参考书目\n谭浩强编：《C语言程序设计》（第4版)，北京：清华大学出版社，2020年\n\n\n严蔚敏、李冬梅、吴伟民编著：《数据结构（C语言版附微课视频）》（第2版)，北京：人民邮电出版社，2017年。\n\n","slug":"exam/2022广东普通专升本考纲(计算机)","date":"2022-01-14T09:25:41.000Z","categories_index":"应试","tags_index":"2022,考纲,升本","author_index":"Jx"},{"id":"50552977e0ec8094596ba83ac872ee52","title":"树和二叉树","content":"\n\n树的存储结构双亲表示法(顺序存储)顺序存储结点数据, 结点中保存父节点在数组中的下标\n优点：找父节点方便；缺点：找孩子不方便\n\n上面的树用实际代码(Java)可表示为:\npublic class ParentTree {\n\n    PTNode nodes[]; // 双亲表示\n\n    int n; // 结点数\n\n    public static void main(String[] args) {\n        ParentTree parentTree = new ParentTree();\n        parentTree.nodes = new PTNode[100];\n        // 根节点固定存储在0, -1表示没有双亲\n        parentTree.nodes[0] = new PTNode(\"A\", -1); \n        parentTree.nodes[1] = new PTNode(\"B\", 0);\n        parentTree.nodes[2] = new PTNode(\"C\", 0);\n        parentTree.nodes[3] = new PTNode(\"D\", 0);\n        parentTree.nodes[4] = new PTNode(\"E\", 1);\n        parentTree.nodes[5] = new PTNode(\"F\", 1);\n        parentTree.nodes[6] = new PTNode(\"G\", 2);\n        parentTree.nodes[7] = new PTNode(\"H\", 3);\n        parentTree.nodes[8] = new PTNode(\"I\", 3);\n        parentTree.nodes[9] = new PTNode(\"J\", 3);\n        parentTree.nodes[10] = new PTNode(\"K\", 4);\n    }\n\n}\n\nclass PTNode&lt;elemType&gt; {\n\n    elemType data; // 数据元素\n\n    int parent; // 双亲位置域\n\n    public PTNode(elemType data, int parent) {\n        this.data = data;\n        this.parent = parent;\n    }\n}\n孩子表示法（顺序+链式存储）顺序存储各个节点，每个节点中保存孩子链表头指针\n \n\n孩子兄弟表示法(链式存储) =&gt; \n\n用二叉链表存储树-左孩子右兄弟\n\n孩子兄弟表示法存储的树, 从存储视角来看形态上和二叉树类似\n森林与二叉树的转换\n本质就是用二叉链表存储森林-左孩子右兄弟\n\n森林中各个树的根结点之间视为兄弟关系\n\n\n\n二叉树(Binary tree)1. 二叉树的概念\n可为空二叉树\n任意结点的度≤2\n是有序树，左子树、右子树不可颠倒2. 特殊二叉树2.1 满二叉树高度为，含有个结点的二叉树\n\n特点:\n\n只有最后一层有叶子结点\n不存在度为 1 的结点\n按层序从 1 开始编号，结点i的左孩子为，右孩子为；结点i的父节点为(如果有的话)\n\n\n2.2 完全二叉树当且仅当其每个结点都与高度为的满二叉树中编号的结点一一对应时，称为完全二叉树。\n在满二叉树的基础上可去掉若干个编号更大的结点。\n特点:\n\n只有最后两层可能有叶子结点\n最多只有一个度为 1 的结点\n按层序从 1 开始编号，结点i的左孩子为，右孩子为；结点i的父节点为(如果有的话)\n\n\n2.3 二叉排序树左子树关键字 &lt; 根节点关键字 &lt; 右子树关键字，具备此性质的二叉树则称为二叉排序树\n\n2.4 平衡二叉树树上任一结点的左右子树深度差不超过1\n\n3. 二叉树的性质\n设非空二叉树中度为0、1和2的结点个数分别为，则（叶子结点比二分支结点多一个）。假设树中结点总数为，则：\n\n①\n②（树的结点数总度数）\n①②\n\n\n二叉树第  层至多有－个结点(i ≥ 1)\n\n叉树第 层至多有－个结点(i ≥ 1)\n\n\n高度为  的二叉树至多有－ 个结点(满二叉树)\n\n高度为的叉树至多有  个结点\n\n\n\n4. 完全二叉树的性质\n具有个 结点的完全二叉树的高度为或\n高为的满二叉树共有－个结点\n高为的完全二叉树至少 － 个结点至多 － 个结点 \n\n\n对于完全二叉树，可以由的结点数推出度为0、1和2的结点个数为、和\n\n完全二叉树最多只有一个度为1的结点，即或\n =&gt; 一定是奇数\n若完全二叉树有个(偶数)个结点，则必有－\n若完全二叉树有个(奇数)个结点，则必有－\n5. 二叉树的存储结构5.1 二叉树的顺序存储在二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来\n\n的左孩子 – \n的右孩子 – \n的父节点 – \n\n最坏情况：高度为且只有个结点的单支树(所有结点只有右孩子)，也至少需要个存储单元。所以，二叉树的顺序存储结构只适合存储完全二叉树\npublic class SeqStorageBinaryTree {\n\n    static int maxSize = 100;\n\n    static TreeNode[] t = new TreeNode[maxSize];\n\n    public static void main(String[] args) {\n        for (int i = 1; i &lt; t.length; i++) {\n            t[i] = new TreeNode(i);\n        }\n    }\n\n}\n\nclass TreeNode {\n    /**\n     * 结点中的数据元素\n     */\n    int value;\n    /**\n     * 结点是否为空\n     */\n    boolean isEmpty;\n\n    public TreeNode(int value) {\n        this.value = value;\n        // 初始化结点为空\n        this.isEmpty = false;\n    }\n\n}\n5.2 二叉树的链式存储个结点的二叉链表共有个空链域\npublic class LinkedStorageBinaryTree {\n\n    public static void main(String[] args) {\n        // 构建上图的二叉树, 后面遍历的代码实现都是基于此树.\n        TreeNodeLinked root = new TreeNodeLinked(1);\n        TreeNodeLinked node1 = new TreeNodeLinked(2);\n        TreeNodeLinked node1 = new TreeNodeLinked(2);\n        TreeNodeLinked node2 = new TreeNodeLinked(3);\n        TreeNodeLinked node3 = new TreeNodeLinked(5);\n        TreeNodeLinked node4 = new TreeNodeLinked(6);\n        TreeNodeLinked node5 = new TreeNodeLinked(7);\n        TreeNodeLinked node6 = new TreeNodeLinked(11);\n        TreeNodeLinked node7 = new TreeNodeLinked(12);\n        root.lChild = node1; root.rChild = node2;\n        node1.lChild = node3;\n        node2.lChild = node4; node2.rChild = node5;\n        node3.rChild = node6;\n        node4.lChild = node7;\n    }\n\n}\n\nclass TreeNodeLinked {\n    \n    int value; // 数据域\n    \n    TreeNodeLinked lChild, rChild; // 左、右孩子\n    \n    public TreeNodeLinked(int value) {\n        this.value = value;\n        this.lChild = null;\n        this.rChild = null;\n    }\n}\n6. 二叉树的遍历6.1 先序遍历(根、左、右)public static void preOrder(TreeNodeLinked tNode) {\n    if(tNode != null) {\n        // 访问根结点\n        System.out.print(tNode.value + \"\");\n        // 递归遍历左子树\n        preOrder(tNode.lChild);\n        // 递归遍历右子树\n        preOrder(tNode.rChild);\n    }\n}\n6.2 中序遍历(左、根、右)public static void midOrder(TreeNodeLinked tNode) {\n    if(tNode != null) {\n        // 递归遍历左子树\n        preOrder(tNode.lChild);\n        // 访问根结点\n        System.out.print(tNode.value + \" \");\n        // 递归遍历右子树\n        preOrder(tNode.rChild);\n    }\n}\n6.3 后序遍历(左、右、根)public static void postOrder(TreeNodeLinked tNode) {\n    if(tNode != null) {\n        // 递归遍历左子树\n        preOrder(tNode.lChild);\n        // 递归遍历右子树\n        preOrder(tNode.rChild);\n        // 访问根结点\n        System.out.print(tNode.value + \" \");\n    }\n}\n6.4 求树的深度(后序遍历算法的变种)public static int treeDepth(TreeNodeLinked t) {\n    if (t == null) {\n        return 0;\n    }\n    int l = treeDepth(t.lChild);\n    int r = treeDepth(t.rChild);\n    // 树的深度 = max(左子树深度, 右子树深度) + 1\n    return Math.max(l, r) + 1;\n}\n6.5 层序遍历(BFS)算法思想:\n\n初始化一个辅助队列\n根节点入队\n若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）\n重复3直至队列为空public static void levelOrder(TreeNodeLinked t) {\n    // 初始化一个辅助队列\n    Queue&lt;TreeNodeLinked&gt; queue = new ArrayBlockingQueue&lt;&gt;(50);\n    // 根结点入队\n    queue.add(t);\n    while(!queue.isEmpty()) {\n        // 队头结点出队\n        TreeNodeLinked poll = queue.poll();\n        System.out.print(poll.value + \" \");\n        // 将左右孩子插入队尾\n        if(poll.lChild != null) {\n            queue.add(poll.lChild);\n        }\n        if(poll.rChild != null) {\n            queue.add(poll.rChild);\n        }\n    }\n}\n\n线索二叉树(Threaded Binary Tree)二叉树添加了直接指向节点的前驱和后继的指针的二叉树称为线索二叉树(Threaded binary tree)\n作用方便从一个指定结点出发，找到其前驱、后继；方便遍历\n存储结构\n在普通二叉树结点的基础上，增加两个标志位 lTag 和rTag\nlTag == 1 时，表示lChild指向前驱；lTag == 0时，表示lChild指向左孩子\nrTag == 1 时，表示rChild指向后继；rTag == 0时，表示lChild指向右孩子public class ThreadNode {\n    /**\n     * 数据域\n     */\n    private int data;\n\n    /**\n     * 左右孩子\n     */\n    private ThreadNode lChild, rChild;\n\n    /**\n     * 左右线索标志, 1为前驱后继, 0为左右孩子\n     */\n    private int lTag, rTag;\n\n    public ThreadNode(int data) {\n        this.data = data;\n        this.lTag = 0; this.rTag = 0;\n    }\n    /* get and set... */\n}\n线索化二叉树中序线索化二叉树/**\n    * 中序线索化二叉树\n    * @param node 二叉树的根节点\n    */\n   public void threadedNodes(ThreadNode node) {\n       if (node == null) {\n           return;\n       }\t\n       // 处理当前结点的前驱结点\n       threadedNodes(node.getlChild());\n       if (node.getlChild() == null) {\n           node.setlChild(pre);\n           node.setlTag(1);\n       }\n       // 处理当前结点的后继结点\n       if (pre != null &amp;&amp; pre.getrChild() == null) {\n           pre.setrChild(node);\n           pre.setrTag(1);\n       }\n       // 每处理完一个结点后, 让当前结点是下一个结点的前驱结点\n       pre = node;\n       threadedNodes(node.getrChild());\n   }\n遍历线索二叉树遍历中序线索二叉树/**\n * 遍历中序线索二叉树\n * @param node 根节点\n */\npublic void threadedNodesList(ThreadNode node) {\n    ThreadNode current = node;\n    while(current != null) {\n        while(current.getlTag() == 0) {\n            current = current.getlChild();\n        }\n        System.out.println(current.getData());\n        // 如果当前结点的右指针指向的是后继结点, 则一直访问\n        while(current.getrTag() == 1) {\n            current = current.getrChild();\n            System.out.println(current.getData());\n        }\n        current = current.getrChild();\n    }\n}\n\n堆(Heap)堆的概念\n堆(Heap)是一种特别的完全二叉树。\n堆分为两种: 最大堆(大根堆)和最小堆(小跟堆), 大顶堆在堆排序中用于升序排序，而小顶堆则是降序排序\n在最大堆中, 父节点的值比每一个子结点的值都要大。在最小堆中，父节点的值比每一个子结点都要小。这就是所谓的“堆属性”, 并且这个属性对堆中的每一个节点都成立.\n\n\n堆节点的访问数组起始位置为0情况下:\n\n父节点的左子节点在位置 \n父节点的右子节点在位置 \n子节点的父节点在位置 堆排序(Heap Sort)最优/最坏时间复杂度: 算法思路a. 假设给定无序序列结构如下:\n\n1.调整成堆将待排序序列构造成一个最大堆/最小堆\nb. 此时我们从最后一个非叶子节点(arr.length/2-1或(i-1)/2 =&gt; (arr.length-1-1)/2)开始, 从左至右, 从下至上进行调整\n\nc. 找到第二个非叶子节点4, 由于[4,9,8]中9元素最大, 4和9交换\n\nd. 这时交换导致了子根节点[4,5,6]结构混乱, 继续调整, 将4和6交换\n\n此时, 就已经将一个无序序列构造成一个大顶堆了\n2.交换元素将堆顶元素与末尾元素交换, 使得最大/最小元素在数组末端\ne. 将堆顶元素9和末尾元素4进行交换\n\n3.反复执行1、2执行完2的交换元素后, 再执行1进行重新调整结构, 使其满足堆的定义, 然后继续执行2…反复执行至序列有序f. 重新调整结构, 使其满足堆定义g. 再将顶堆元素8与末尾元素5进行交换, 得到第二大元素8    e.  反复执行1、2，直至序列有序\n代码实现(Java)import java.util.Arrays;\n\npublic class HeapSort {\n\n    public static void main(String[] args) {\n        int[] arr = {4, 6, 8, 5, 9};\n        heapSort(arr);\n    }\n\n    public static void heapSort(int[] arr) {\n        int temp = 0;\n        // 1. 将无序序列构建成一个堆, 根据升序降序需求选择大顶堆或小顶堆\n        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {\n            adjustHeap(arr, i, arr.length);\n        }\n        // 2.将顶堆元素与末尾元素交换, 将最大元素移动到数组末端\n        for (int j = arr.length - 1; j &gt; 0; j--) {\n            temp = arr[j];\n            arr[j] = arr[0];\n            arr[0] = temp;\n            adjustHeap(arr, 0, j);\n        }\n        // 3. 重新调整结构, 使其满足堆定义, 然后继续交换顶堆元素与当前末尾元素, 反复执行2,3, 直到整个序列有序\n\n        System.out.println(Arrays.toString(arr));\n    }\n\n    /**\n     * 将一个二叉树, 调整成大顶堆\n     * @param arr    待调整的数组\n     * @param i      表示非叶子结点在数组中索引\n     * @param length 表示对多少个元素继续调整, length是在逐渐的减少\n     */\n    public static void adjustHeap(int[] arr, int i, int length) {\n        int temp = arr[i];\n\n        // 循环将以i为父结点的树的最大值放在最顶\n        for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) {\n            // 如果左子结点小于右子结点的值, 则k指向右子结点\n            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) {\n                k++;\n            }\n            // 如果子结点大于父节点\n            if (arr[k] &gt; temp) {\n                // 把较大值赋给当前结点\n                arr[i] = arr[k];\n                // i指向k, 继续循环比较\n                i = k;\n            } else {\n                break;\n            }\n        }\n\n        // 将temp值放到调整后的位置\n        arr[i] = temp;\n    }\n\n}\n\n哈夫曼树(Huffman Tree)概念结点的权: 有某种现实含义的数值(如：表示结点的重要性等)\n结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上的权值的乘机，简言之就是经过的边数*权值\n树的带权路径长度：树中所有叶结点的带权路径长度之和（WPL, Weighted Path Length）\n在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称最优二叉树\n下图中的第二和第三颗二叉树就是哈夫曼树\n\n构造哈夫曼树\n算法思路给定个权值分别为的结点，构造哈夫曼树的算法描述如下：（1）将这个结点分别作为棵仅含一个结点的二叉树，构成森林\n（2）构造一个新结点，从中选取两颗根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和\n（3）从中删除刚才选出的两棵树，同时将新得到的树加入中\n（4）重复(2)和(3)，直至中只剩下一棵树为止\n如下图:\n\n代码实现import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class HuffmanTree {\n\n    public static void main(String[] args) {\n        int[] arr = {1, 3, 2, 2, 7};\n        HuffmanNode root = createHuffmanTree(arr);\n        preOrder(root); // 15 7 8 3 1 2 5 2 3\n        System.out.println();\n        midOrder(root); // 7 15 1 3 2 8 2 5 3\n    }\n\n    public static HuffmanNode createHuffmanTree(int[] arr) {\n        List&lt;HuffmanNode&gt; huffmanNodes = new ArrayList&lt;&gt;();\n        for (int i : arr) {\n            huffmanNodes.add(new HuffmanNode(i));\n        }\n        while(huffmanNodes.size() &gt; 1) {\n            Collections.sort(huffmanNodes);\n            HuffmanNode parentNode = new HuffmanNode(huffmanNodes.get(0).value + huffmanNodes.get(1).value);\n            parentNode.left = huffmanNodes.get(0);\n            parentNode.right = huffmanNodes.get(1);\n            huffmanNodes.add(parentNode);\n            huffmanNodes.remove(parentNode.left);\n            huffmanNodes.remove(parentNode.right);\n\n        }\n        return huffmanNodes.get(0);\n    }\n\n    public static void preOrder(HuffmanNode node) {\n        if (node == null) {\n            return;\n        }\n        System.out.print(node.value + \" \");\n        preOrder(node.left);\n        preOrder(node.right);\n    }\n\n    public static void midOrder(HuffmanNode node) {\n        if (node == null) {\n            return;\n        }\n        midOrder(node.left);\n        System.out.print(node.value + \" \");\n        midOrder(node.right);\n    }\n\n}\n\nclass HuffmanNode implements Comparable&lt;HuffmanNode&gt; {\n\n    int value;\n\n    HuffmanNode left;\n\n    HuffmanNode right;\n\n    public HuffmanNode(int value) {\n        this.value = value;\n    }\n\n    @Override\n    public int compareTo(HuffmanNode o) {\n        return this.value - o.value;\n    }\n\n    @Override\n    public String toString() {\n        return \"HuffmanNode{\" +\n                \"value=\" + value +\n                \", left=\" + left +\n                \", right=\" + right +\n                '}';\n    }\n}\n哈夫曼编码(Huffman Coding)简介\n霍夫曼编码（英语：Huffman Coding），又译为哈夫曼编码、赫夫曼编码，是一种用于无损数据压缩的熵编码（权编码）算法。由美国计算机科学家大卫·霍夫曼（David Albert Huffman）在1952年发明。\nHuffman编码是可变长(VLC)编码的一种, Huffman编码是前缀编码.\n固定长度编码: 每个字符用相等长度的二进制位表示\n可变长度编码(VLC): 允许对不同字符用不等长的二进制位表示\n前缀编码(prefix code): 任何字符的编码都不是另一字符编码的前缀, 即可做到无二义地解码\n\n例子:\n这个句子“this is an example of a huffman tree”中得到的字母频率来构建哈夫曼树。句中字母的编码和频率如图所示。编码此句子需要135 bit（不包括保存树所用的空间）\n\n\n\n字母\n频率\n编码\n\n\n\nspace\n7\n111\n\n\na\n4\n010\n\n\ne\n4\n000\n\n\nf\n3\n1101\n\n\nh\n2\n1010\n\n\ni\n2\n1000\n\n\nm\n2\n0111\n\n\nn\n2\n0010\n\n\ns\n2\n1011\n\n\nt\n2\n0110\n\n\nl\n1\n11001\n\n\no\n1\n00110\n\n\np\n1\n10011\n\n\nr\n1\n11000\n\n\nu\n1\n00111\n\n\nx\n1\n10010\n\n\n算法思路\n统计字符串各个字符对应的个数\n对照字符出现的次数构建一颗哈夫曼树, 次数作为权值\n从小到大进行排序, 将每一个数据, 每个数据都是一个节点, 每个节点可以看成是一颗最简单的二叉树\n取出根结点权值最小的两颗二叉树组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和\n再将这颗新的二叉树以根节点的权值大小再次排序, 不断重复a-b-c, 直至数列中所有数据都处理完毕构建成哈夫曼树\n\n\n根据哈夫曼树给各个字符进行规定编码(前缀编码), 向左的路径为0, 向右的路径为1\n对字符串进行哈夫曼编码处理:\n编码(压缩)\n将哈夫曼码的字符串str的长度对8取余((str.length()+7)/8)得到长度len\n创建长度为len的字节数组huffmanCodeBytes用于存放压缩的数据\n以跨度为8循环遍历str, 将取出的每8个子字符串(bit)转化为字节类型并放入huffmanCodeBytes中\n\n\n解码(解压)\n将经过哈夫曼编码的字节数组转换成二进制字符串\n遍历二进制字符串对照Huffman编码表进行解码(需要将字节转换成二进制的字符串)代码实现import java.util.*;\n\npublic class HuffmanCoding {\n\n    static Map&lt;Byte, String&gt; huffmanCodesMap;\n\n    public static void main(String[] args) {\n        String str = \"this is an example of a huffman tree\";\n        System.out.println(\"source =&gt; \" + Arrays.toString(str.getBytes()));\n        byte[] zip = huffmanZip(str.getBytes());\n        System.out.println(\"压缩哈弗曼编码后 =&gt; \" + Arrays.toString(zip));\n        byte[] decode = decode(huffmanCodesMap, zip);\n        System.out.println(\"解码哈弗曼编码后 =&gt; \" + Arrays.toString(decode));\n    }\n\n    /**\n     * 哈夫曼解码\n     *\n     * @param huffmanCodesMap 哈夫曼码表\n     * @param huffmanBytes    哈夫曼字节数组\n     * @return 解码后的字节数组\n     */\n    private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodesMap, byte[] huffmanBytes) {\n        StringBuilder stringBuilder = new StringBuilder();\n        // 将经过哈夫曼编码后的字节数组转换成二进制字符串\n        for (int i = 0; i &lt; huffmanBytes.length; i++) {\n            byte b = huffmanBytes[i];\n            // 判断是否是最后一个字节\n            boolean flag = (i == huffmanBytes.length - 1);\n            stringBuilder.append(byteToBitString(!flag, b));\n        }\n        // 方便进行反查\n        Map&lt;String, Byte&gt; map = new HashMap&lt;String, Byte&gt;();\n        for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodesMap.entrySet()) {\n            map.put(entry.getValue(), entry.getKey());\n        }\n        List&lt;Byte&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; stringBuilder.length(); ) {\n            int count = 1;\n            Byte b;\n            while (true) {\n                String key = stringBuilder.substring(i, i + count);\n                if ((b = map.get(key)) == null) {\n                    count++;\n                } else {\n                    break;\n                }\n            }\n            list.add(b);\n            i += count;\n        }\n        byte[] b = new byte[list.size()];\n        for (int i = 0; i &lt; b.length; i++) {\n            b[i] = list.get(i);\n        }\n        return b;\n    }\n\n    /**\n     * 将字节转换成二进制的字符串\n     *\n     * @param flag 是否需要补高位, true为需要补高位, false则不补(最后一个字节则无需补高位)\n     * @param b    byte\n     * @return 二进制字符串\n     */\n    private static String byteToBitString(boolean flag, byte b) {\n        int temp = b;\n        if (flag) {\n            temp |= 256;\n        }\n        String str = Integer.toBinaryString(temp);\n        if (flag) {\n            return str.substring(str.length() - 8);\n        } else {\n            return str;\n        }\n    }\n\n    /**\n     * 哈夫曼编码压缩\n     *\n     * @param bytes 待压缩的字节数组\n     * @return 压缩后的字节数组\n     */\n    private static byte[] huffmanZip(byte[] bytes) {\n        Map&lt;Byte, Integer&gt; countMap = new HashMap&lt;&gt;();\n        for (byte c : bytes) {\n            if (countMap.containsKey(c)) {\n                countMap.put(c, countMap.get(c) + 1);\n            } else {\n                countMap.put(c, 1);\n            }\n        }\n        HuffmanNode huffmanTreeRootNode = HuffmanTree.createHuffmanTree(countMap);\n        Map&lt;Byte, String&gt; codeMap = getCodeMap(huffmanTreeRootNode);\n        // 放到全局变量中, 方便调用测试\n        huffmanCodesMap = codeMap;\n        // 将各个字符进行哈夫曼编码\n        StringBuilder compressedStr = new StringBuilder();\n        for (byte b : bytes) {\n            compressedStr.append(codeMap.get(b));\n        }\n        // 对哈夫曼编码进行压缩\n        return zip(compressedStr.toString(), codeMap);\n    }\n\n    /**\n     * 压缩哈弗曼编码\n     *\n     * @param huffmanCodeStr 哈夫曼编码后的字符串\n     * @param codeMap        哈弗曼编码表\n     * @return\n     */\n    private static byte[] zip(String huffmanCodeStr, Map&lt;Byte, String&gt; codeMap) {\n        // 对8取余\n        int len = (huffmanCodeStr.length() + 7) / 8;\n        byte[] huffmanCodeBytes = new byte[len];\n        for (int i = 0, index = 0; i &lt; huffmanCodeStr.length(); i += 8, index++) {\n            String strByte;\n            if (i + 8 &gt; huffmanCodeStr.length()) {\n                strByte = huffmanCodeStr.substring(i);\n            } else {\n                strByte = huffmanCodeStr.substring(i, i + 8);\n            }\n            // !!!难点!!!\n            huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);\n        }\n        return huffmanCodeBytes;\n    }\n\n    /**\n     * 获取哈夫曼编码表\n     *\n     * @param root 哈夫曼树头结点\n     * @return 编码表\n     */\n    private static Map&lt;Byte, String&gt; getCodeMap(HuffmanNode root) {\n        Map&lt;Byte, String&gt; map = new HashMap&lt;&gt;();\n        getRouteToMap(root, \"\", new StringBuilder(), map);\n        return map;\n    }\n\n    /**\n     * 递归获取路径\n     *\n     * @param node 哈夫曼树节点\n     * @param code 0表示左, 1表示右\n     * @param sb   拼接的路径\n     * @param map  最终形成的哈弗曼编码表\n     */\n    private static void getRouteToMap(HuffmanNode node, String code, StringBuilder sb, Map&lt;Byte, String&gt; map) {\n        StringBuilder stringBuilder = new StringBuilder(sb);\n        stringBuilder.append(code);\n        if (node == null) {\n            return;\n        }\n        if (node.left == null &amp;&amp; node.right == null) {\n            // 是叶子结点\n            map.put(node.data, stringBuilder.toString());\n            return;\n        }\n        getRouteToMap(node.left, \"0\", stringBuilder, map);\n        getRouteToMap(node.right, \"1\", stringBuilder, map);\n    }\n}\n\nclass HuffmanTree {\n\n    public static HuffmanNode createHuffmanTree(Map&lt;Byte, Integer&gt; countMap) {\n        List&lt;HuffmanNode&gt; huffmanNodes = new ArrayList&lt;&gt;();\n        for (Byte data : countMap.keySet()) {\n            Integer height = countMap.get(data);\n            huffmanNodes.add(new HuffmanNode(data, height));\n        }\n        while (huffmanNodes.size() &gt; 1) {\n            Collections.sort(huffmanNodes);\n            HuffmanNode parentNode = new HuffmanNode(huffmanNodes.get(0).height + huffmanNodes.get(1).height);\n            parentNode.left = huffmanNodes.get(0);\n            parentNode.right = huffmanNodes.get(1);\n            huffmanNodes.add(parentNode);\n            huffmanNodes.remove(parentNode.left);\n            huffmanNodes.remove(parentNode.right);\n        }\n        return huffmanNodes.get(0);\n    }\n\n}\n\nclass HuffmanNode implements Comparable&lt;HuffmanNode&gt; {\n\n    Byte data;\n\n    int height;\n\n    HuffmanNode left;\n\n    HuffmanNode right;\n\n    @Override\n    public int compareTo(HuffmanNode o) {\n        return this.height - o.height;\n    }\n\n    public HuffmanNode(int height) {\n        this.height = height;\n    }\n\n    public HuffmanNode(Byte data, int height) {\n        this.data = data;\n        this.height = height;\n    }\n\n    @Override\n    public String toString() {\n        return \"HuffmanNode{\" +\n                \"data=\" + data +\n                \", height=\" + height +\n                \", left=\" + left +\n                \", right=\" + right +\n                '}';\n    }\n}\n\n\n\n\n\n二叉排序树(BST)概念\n\n二叉排序树(Binary Sort Tree), 也称为有序二叉树(ordered binary tree)或二叉查找树(Binary Search Tree), 是一颗空树或具有以下性质的二叉树:\n\n若任意若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n任意节点的左、右子树也分别为二叉查找树；\n\n\nBST相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为。\n\n\n\n算法\n平均\n最差\n\n\n\n空间\nO(n)\nO(n)\n\n\n搜索\nO(log n)\nO(n)\n\n\n插入\nO(log n)\nO(n)\n\n\n删除\nO(log n)\nO(n)\n\n\n\nBST是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。\n插入我们将要插入的结点称为node, 则插入node\n\n\n\n如果node为空则直接返回\n如果当前要插入节点\n\n查找\n如果当前node为空, 则搜索失败\n如果要搜索的值等于当前node的值, 则查找成功\n如果当前node的值&gt;要搜索的值, 则搜索左子树; 否则搜索右子树\n\n删除BST的删除情况比较复杂, 有下面三种情况需要考虑\n\n**删除叶子节点(比如1, 4, 7, 13)    **\n\n先找到要删除的节点targetNode\n找到targetNode的父节点parent\n判断targetNode是parent的左还是右子节点对应删除\n\n\n删除只有一颗子树的节点(比如14)\n\n先找到要删除的节点targetNode\n\n找到targetNode的父节点parent\n\n确定targetNode的子节点是左子节点还是子节点\n\n确定targetNode是parent的左子节点还是右子节点\n\n如果targetNode有左子节点\n\n如果targetNode是parent的**左子节点 **=&gt; parent.left = targetNode.left;\n\n如果targetNode是parent的右子节点 =&gt; parent.right = targetNode.left;\n\n\n\n如果targetNode有右子节点\n\n如果targetNode是parent的左子节点 =&gt; parent.left = targetNode.right;\n\n如果targetNode是parent的右子节点 =&gt; parent.right = targetNode.right;\n\n\n\n\n\n删除两颗子树的节点(比如8, 3, 6)\n\n先找到要删除的节点targetNode\n找到targetNode的父节点parent\n从targetNode的右子树中找到最小的节点(中序遍历)\n用一个临时变量将最小节点的值保存并删除该结点\ntargetNode.value = temp代码实现public class BinarySearchTree {\n\n    private BSTNode root = null;\n\n    public void add(BSTNode node) {\n        if (this.root == null) {\n            // root is empty then put the node.\n            this.root = node;\n        } else {\n            this.root.add(node);\n        }\n    }\n\n    public BSTNode searchParent(int targetVal) {\n        return searchParent(targetVal, this.root);\n    }\n\n    /**\n     * find the parent node of the target node\n     *\n     * @param targetVal Value of the target node\n     * @param node      BST node\n     * @return Parent node of the target\n     */\n    private BSTNode searchParent(int targetVal, BSTNode node) {\n        if (node == null) {\n            return null;\n        }\n        if ((node.left != null &amp;&amp; node.left.value == targetVal) || (node.right != null &amp;&amp; node.right.value == targetVal)) {\n            return node;\n        }\n        if (targetVal &lt; node.value) {\n            return searchParent(targetVal, node.left);\n        } else if (targetVal &gt; node.value) {\n            return searchParent(targetVal, node.right);\n        }\n        return null;\n    }\n\n    public BSTNode search(int targetVal) {\n        return search(this.root, targetVal);\n    }\n\n    private BSTNode search(BSTNode node, int targetVal) {\n        if (node == null) {\n            return null;\n        }\n        if (node.value == targetVal) {\n            return node;\n        }\n        if (node.value &gt; targetVal) {\n            return search(node.left, targetVal);\n        } else {\n            return search(node.right, targetVal);\n        }\n    }\n\n    public BSTNode searchMinNode(BSTNode node) {\n        if (node.left == null) {\n            return node;\n        }\n        return searchMinNode(node.left);\n    }\n\n    public void delete(int value) {\n        BSTNode targetNode = search(value);\n        if(targetNode == null) {\n            System.out.println(\"Cannot found target node.\");\n            return;\n        }\n        // Only one node.\n        if(root.left == null &amp;&amp; root.right == null) {\n            root = null;\n            return;\n        }\n        BSTNode parent = searchParent(value);\n        // case 1: target node is the leaf node.\n        if (targetNode.left == null &amp;&amp; targetNode.right == null) {\n            if (parent.left == targetNode) {\n                parent.left = null;\n            } else if (parent.right == targetNode) {\n                parent.right = null;\n            } else {\n                System.out.println(\"delete fail(case 1)\");\n            }\n            return;\n        }\n        // case 2: target node has only left or right child tree.\n        if (targetNode.left != null &amp;&amp; targetNode.right == null) {\n            if (parent.left == targetNode) {\n                parent.left = targetNode.left;\n            } else if (parent.right == targetNode) {\n                parent.right = targetNode.left;\n            } else {\n                System.out.println(\"delete fail(case 2)\");\n            }\n            return;\n        }\n        if (targetNode.right != null &amp;&amp; targetNode.left == null) {\n            if (parent.left == targetNode) {\n                parent.left = targetNode.right;\n            } else if (parent.right == targetNode) {\n                parent.right = targetNode.right;\n            } else {\n                System.out.println(\"delete fail(case 2)\");\n            }\n            return;\n        }\n        // case 3: target node has two child tree.\n        if (targetNode.left != null &amp;&amp; targetNode.right != null) {\n            BSTNode minNode = searchMinNode(targetNode.right);\n            int minVal = minNode.value;\n            BSTNode minNodeParent = searchParent(minNode.value);\n            // delete min node.\n            delete(minNode.value);\n            // assign the value of min node of the right child tree to the target node.\n            targetNode.value = minVal;\n        }\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree bst = new BinarySearchTree();\n        int[] arr = {8, 3, 10, 1, 6, 14, 4, 7, 13};\n        for (int i : arr) {\n            bst.add(new BSTNode(i));\n        }\n        bst.delete(6);\n        System.out.println(bst.root);\n    }\n\n}\n\nclass BSTNode {\n\n    int value;\n\n    /**\n     * left child tree\n     */\n    BSTNode left;\n\n    /**\n     * right child tree\n     */\n    BSTNode right;\n\n    public BSTNode(int value) {\n        this.value = value;\n    }\n\n    /**\n     * insert node\n     *\n     * @param node node to insert\n     */\n    public void add(BSTNode node) {\n        if (node == null) {\n            return;\n        }\n        // judge whether the value of the target node is smaller than the value of the current node.\n        if (node.value &lt; this.value) {\n            if (this.left == null) {\n                this.left = node;\n            } else {\n                this.left.add(node);\n            }\n        } else {\n            if (this.right == null) {\n                this.right = node;\n            } else {\n                this.right.add(node);\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"BSTNode{\" +\n                \"value=\" + value +\n                \", left=\" + left +\n                \", right=\" + right +\n                '}';\n    }\n}\n\n\n\n平衡二叉树(AVL树)概念\n自平衡二叉查找树, 简称平衡树(AVL树, Adelson-Velsky and Landis Tree)\n树上任一结点的左子树和右子树高度只差不超过1\n结点的平衡因子 = 左子树高 - 右子树高\n平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。\n\n\n算法\n平均\n最差\n\n\n\n空间\nO(n)\nO(n)\n\n\n搜索\nO(log n)\nO(log n)\n\n\n插入\nO(log n)\nO(log n)\n\n\n删除\nO(log n)\nO(log n)\n\n\n\n\n插入操作\nAVL树和二叉排序树一样，找到合适的位置插入\n新插入的结点可能导致其祖先们平衡因子改变，导致失衡\n\n\n调整”不平衡”\n找到最小不平衡子树进行调整, 记最小不平衡子树的根为A, 则:\n\n\n\n位置\n调整\n\n\n\nLL(在A的左孩子的左子树中插入导致不平衡)\n将A的左孩子右上旋\n\n\nRR(在A的右孩子的右子树中插入导致不平衡)\n将A的右孩子左上旋\n\n\nLR(在A的左孩子的右子树中插入导致不平衡)\n将A的左孩子的右孩子 先左上旋再右上旋\n\n\nRL(在A的右孩子的左子树中插入导致不平衡)\n将A的右孩子的左孩子 先右上旋再左上旋\n\n\n左旋\n创建一个新的结点newNode, 其值为最小不平衡子树的根结点的值(以下都称为当前结点)\n把newNode的左子树设置成当前结点的左子树\n把newNode的右子树设置成当前结点的右子树的左子树\n把当前结点的值换成右子树的值\n把当前结点的右子树设置成右子树的右子树\n把当前结点的左子树设置成newNode\n\n\n右旋\n创建一个新的结点newNode, 其值为最小不平衡子树的根结点的值(以下都称为当前结点)\n把newNode的右子树设置成当前结点的右子树\n把newNode的左子树设置成当前结点的左子树的右子树\n把当前结点的值换成左子树的值\n把当前结点的左子树设置成左子树的右子树\n把当前结点的右子树设置成newNode\n\n\n代码实现public class AVLTree&lt;T extends Comparable&lt;T&gt;&gt; {\n\n    private AVLNode&lt;T&gt; root;\n\n    public AVLNode&lt;T&gt; search(T targetVal) {\n        return search(this.root, targetVal);\n    }\n\n    private AVLNode&lt;T&gt; searchParent(T targetVal) {\n        return searchParent(targetVal, this.root);\n    }\n\n    public void addNode(AVLNode&lt;T&gt; node) {\n        if (node == null) {\n            return;\n        }\n        if (this.root == null) {\n            this.root = node;\n            return;\n        }\n        AVLNode&lt;T&gt; parentNode = searchParent(node.value, root);\n        int cmp = node.value.compareTo(parentNode.value);\n        if (cmp &gt; 0) {\n            parentNode.right = node;\n        } else {\n            parentNode.left = node;\n        }\n        // adjust imbalance\n        if (Math.abs(getLeftTreeHeight() - getRightTreeHeight()) &gt; 1) {\n            AVLNode&lt;T&gt; minImbalanceNode = searchParent(parentNode.value);\n            if (minImbalanceNode.left == parentNode &amp;&amp; parentNode.left == node) {\n                // LL\n                rotateRight(minImbalanceNode);\n            } else if (minImbalanceNode.right == parentNode &amp;&amp; parentNode.right == node) {\n                // RR\n                rotateLeft(minImbalanceNode);\n            } else if (minImbalanceNode.left == parentNode &amp;&amp; parentNode.right == node) {\n                // LR\n                rotateLeft(minImbalanceNode);\n                rotateRight(minImbalanceNode);\n            } else if (minImbalanceNode.right == parentNode &amp;&amp; parentNode.left == node) {\n                // RL\n                rotateRight(minImbalanceNode);\n                rotateLeft(minImbalanceNode);\n            }\n\n        }\n    }\n\n    private AVLNode&lt;T&gt; search(AVLNode&lt;T&gt; node, T targetVal) {\n        if (node == null) {\n            return null;\n        }\n        int cmp = node.value.compareTo(targetVal);\n        if (cmp == 0) {\n            return node;\n        }\n        if (cmp &gt; 0) {\n            return search(node.left, targetVal);\n        } else {\n            return search(node.right, targetVal);\n        }\n    }\n\n    private AVLNode&lt;T&gt; searchParent(T targetVal, AVLNode&lt;T&gt; node) {\n        if (node == null) {\n            return null;\n        }\n        int cmp = targetVal.compareTo(node.value);\n        if ((node.left != null &amp;&amp; node.left.value == targetVal) ||\n                (node.right != null &amp;&amp; node.right.value == targetVal)) {\n            return node;\n        }\n        if (cmp &lt; 0) {\n            if (node.left == null) {\n                return node;\n            }\n            return searchParent(targetVal, node.left);\n        } else if (cmp &gt; 0) {\n            if (node.right == null) {\n                return node;\n            }\n            return searchParent(targetVal, node.right);\n        }\n        return null;\n    }\n\n    public int getTreeHeight(AVLNode&lt;T&gt; node) {\n        if (node == null) {\n            return 0;\n        }\n        return Math.max(getTreeHeight(node.left), getTreeHeight(node.right)) + 1;\n    }\n\n    public int getLeftTreeHeight() {\n        return getTreeHeight(this.root.left);\n    }\n\n    public int getRightTreeHeight() {\n        return getTreeHeight(this.root.right);\n    }\n\n    public void rotateLeft(AVLNode&lt;T&gt; node) {\n        AVLNode&lt;T&gt; newNode = new AVLNode&lt;&gt;(node.value);\n        newNode.left = node.left;\n        newNode.right = node.right.left;\n        node.value = node.right.value;\n        node.right = node.right.right;\n        node.left = newNode;\n    }\n\n    public void rotateRight(AVLNode&lt;T&gt; node) {\n        AVLNode&lt;T&gt; newNode = new AVLNode&lt;&gt;(node.value);\n        newNode.right = node.right;\n        newNode.left = node.left.right;\n        node.value = node.left.value;\n        node.left = node.left.left;\n        node.right = newNode;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {50, 26, 66, 21, 30, 60, 70, 68, 67, 99, 88, 41, 22, 55, 61, 46, 46, -10, 4, 55, 99, 46 ,40};\n        AVLTree&lt;Integer&gt; tree = new AVLTree&lt;&gt;();\n        for (int i : arr) {\n            tree.addNode(new AVLNode&lt;&gt;(i));\n        }\n        System.out.println(tree.root);\n        System.out.println(tree.search(70));\n        System.out.println(tree.getLeftTreeHeight());\n        System.out.println(tree.getRightTreeHeight());\n    }\n\n}\n\nclass AVLNode&lt;T extends Comparable&lt;T&gt;&gt; {\n\n    T value;\n\n    AVLNode&lt;T&gt; left;\n\n    AVLNode&lt;T&gt; right;\n\n    public AVLNode(T value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return \"AVLNode{\" +\n                \"value=\" + value +\n                \", left=\" + left +\n                \", right=\" + right +\n                '}';\n    }\n\n}\n\n","slug":"data-structure/树和二叉树","date":"2022-01-14T05:11:25.000Z","categories_index":"数据结构","tags_index":"考研,树","author_index":"Jx"},{"id":"0b9c5318228023fdd1e179358a45ba07","title":"图","content":"\n\n图的基本概念\n\n\n\n\n\n\n\n\n图是一种复杂的非线性结构。在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素（除第一个和最后一个）只有一个直接前趋和一个直接后继；在树形结构中，数据元素之间有明显的层次关系，并且每个数据元素只与上一层中的一个元素（parent node）及下一层的多个元素（child node）相关；而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。\n图的定义图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V, E),其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若，则用 |V| 表示图G中顶点的个数，也称图G的阶, , 用 |E| 表示图G中边的条数。\n无向图(undirected graph)若E是无向边(简称边)的有限集合时，则图G为无向图。边是顶点无序对，记成（v, w）或 (w, v), 因为**(v, w) = (w, v), 其中v, w是顶点。可以说顶点w和顶点v互为邻接点**。边（v，w）依附于顶点w和v，或者说边（v，w）和顶点v、w相关联。\n有向图(directed graph)若E是有向边(也称弧)的有限集合时，则图G为有向图(digraph)。弧是顶点的有序对，记为，其中v、w是顶点，v称为弧尾，w称为弧头，&lt;v, w&gt;称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。\n顶点的度、入度、出度无向图顶点v的度是指依附于该顶点的边的条数，记为在具有n个顶点、e条边的无向图中，即无向图的全部顶点的度的和等于边数的2倍\n有向图入度(in-degree) 是以顶点v为终点的有向边的数目。记为出度(out-degree)是以顶点v为起点的有向边的数目, 记为顶点v的度等于其入度和出度之和, 即在具有n个顶点、e条边的有向图中，\n顶点-顶点的关系描述\n路径: 顶点到顶点之间的一条路径是指顶点序列，\n回路: 第一个顶点和最后一个顶点相同的路径称为回路或环\n简单路径: 在路径序列中, 顶点不重复出现的路径称为简单路径\n简单回路: 除第一个顶点和最后一个顶点外, 其余顶点不重复出现的回路称为简单回路\n路径长度: 路径上边的数目\n点到点的距离: 从顶点u出发到顶点v的最短路径若存在, 则此路径的长度称为从u到v的距离。若u到v根本不存在路径，则记该距离为无穷（∞）。\n无向图中, 若从顶点v到顶点w有路径存在, 则称v和w是连通的\n有向图中, 若从顶点v到顶点w和从顶点w到顶点v之间都有路径, 则称这两个顶点是强连通的连通图若图G中任意两个顶点都是连通的, 则称图G为连通图, 否则称为非连通图对于n个顶点的无向图G若G是连通图, 则最少有n-1条边若G是非连通图, 则最多可能有条边强连通图若图中任何一对顶点都是强连通的, 则称此图为强连通图对于n个顶点的有向图G, 若G是强连通图, 则最少有n条边(形成回路)图的局部子图设两个图和, 若是的子集, 且是的子集, 则称是的子图若有满足的子图, 则称其为的生成子图连通分量无向图中的极大连通子图称为连通分量。\n\n极大连通子图: 子图必须连通, 且包含尽可能多的顶点和边\n强连通分量有向图中的极大强连通子图称为有向图的强连通分量极大强连通子图: 子图必须强连通, 且保留尽可能多的边\n生成树连通图的生成树是包含图中全部顶点的一个极小连通子图(边尽可能的少, 但要保持连通)若图中顶点数为n, 则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路 \n生成森林在非连通图中, 连通分量的生成树构成了非连通图的生成森林\n边的权、带全图/网边的权: 在一个图中, 每条边有可以表上具有某种含义的数值, 该数值称为该边的权值带权图/网: 边上带有权值的图称为带权图, 也称网带权路径长度: 当图是带权图时, 一条路径上所有边的权值之和, 称为该路径的带权路径长度\n特殊形态的图无向完全图无向完全图: 无向图中任意两个顶点之间都存在边若无向图的顶点树为, 则\n有向完全图有向完全图: 有向图中任意两个顶点之间都存在方向相反的两条弧若有向图的顶点数，则\n稀疏图边数很少的图称为稀疏图(没有绝对的界限, 一般来说)时, 可以将G视为稀疏图\n稠密图稀疏图反之对应的是稠密图\n树树: 不存在回路, 且连通的无向图n个顶点的树, 必有n-1条边 ** =&gt;**  n个顶点的图, 若, 则一定有回路\n有向树有向树: 一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树\n常见考点对于n个顶点的无向图G,\n\n所有顶点的度之和=2|E|\n若G是连通图, 则最少有n-1条边(树), 若 |E| &gt; n-1, 则一定有回路\n若G是非连通图, 则最多可能有条边\n无向完全图共有条边\n\n对于n个顶点的有向图G,\n\n所有顶点的出度之和=入度之和=|E|\n所有顶点的度之和=2|E|\n若G是强连通图, 则最少有n条边(形成回路)\n有向完全图共有条边\n\n图的存储\n\n\n\n邻接矩阵\n邻接表\n十字链表\n邻接多重表\n\n\n\n空间复杂度\nO(\nV\n²)\n无向图O(\n\n\n有向图O(\nV\n+\nE\n)\n\n\n找相邻边\n遍历对应行或列\n\n\n\n\n\n时间复杂度为O(\nV\n)\n找有向图的入边必须遍历整个邻接表\n很方便\n\n\n删除边或顶点\n删除边很方便, 删除顶点需要大量移动数据\n无向图中删除边或顶点都不方便\n很方便\n很方便\n\n\n适用于\n稠密图\n稀疏图和其他\n只能存有向图\n只能存无向图\n\n\n表示方式\n唯一\n不唯一\n不唯一\n不唯一\n\n\n邻接矩阵结点数为n的图的邻接矩阵A是的. 将G的顶点编号为, 则若或是中的边若或不是中的边\n性质设图G的邻接矩阵为(矩阵元素为0/1), 则的元素等于由顶点 i 到顶点 j 的长度为 n 的路径的数目\n顶点的度、出度、入度无向图:\n\n第i个结点的度=第i行(或第i列)的非零元素个数\n\n有向图:\n\n第i个结点的出度 = 第i行的非零元素个数\n第i个结点的入度 = 第i列的非零元素个数\n第i个结点的度 = 第i行、第i列的非零元素个数之和\n\n邻接矩阵法求顶点的度、出度、入度的时间复杂度为\n性能空间复杂度:  只和顶点数相关, 和实际边数无关适合用于存储稠密图无向图的邻接矩阵是对称矩阵, 可以压缩存储(只存储上三角区或下三角区)\n压缩存储策略: 只存储主对角线+下三角区。按行优先原则将各元素存入一维数组中。\n对称矩阵的性质矩阵下标一维数组下标下三角区和主对角线元素上三角区元素\n代码实现import lombok.Data;\n\nimport java.util.*;\n\n@Data\npublic class Graph&lt;T extends Comparable&lt;T&gt;&gt; {\n\n    /**\n     * storage vertex\n     */\n    private List&lt;T&gt; vertexList;\n\n    /**\n     * storage adjacency matrix of the graph\n     */\n    private int[][] edges;\n\n    /**\n     * denotes the number of edges\n     */\n    private int numOfEdges;\n\n\n    public Graph(int n) {\n        edges = new int[n][n];\n        vertexList = new ArrayList&lt;&gt;(n);\n        numOfEdges = 0;\n    }\n    \n    /**\n     * add vertex to vertexList\n     *\n     * @param vertex vertex of graph\n     */\n    public void insertVertex(T vertex) {\n        vertexList.add(vertex);\n    }\n\n    /**\n     * add edge\n     *\n     * @param v1     index of first vertex\n     * @param v2     index of second vertex\n     * @param weight weight value of vertex\n     */\n    public void insertEdge(int v1, int v2, int weight) {\n        edges[v1][v2] = weight;\n        edges[v2][v1] = weight;\n        numOfEdges++;\n    }\n\n    public void show() {\n        for (int[] edge : edges) {\n            System.out.println(Arrays.toString(edge));\n        }\n    }\n}\n邻接表法邻接表采用顺序+链式的方式存储\n\n\n\n\n邻接表\n邻接矩阵\n\n\n\n空间复杂度\n无向图O(\nV\n\n\n适合用于\n存储稀疏图\n存储稠密图\n\n\n表示方式\n不唯一\n唯一\n\n\n计算度/出度/入度\n计算有向图的度/入度不方便, 其余方便\n必须遍历对应行或列\n\n\n找相邻的边\n找到有向图的入边不方便, 其余方便\n必须遍历对应行或列\n\n\n// 边/弧的结点\nclass ArcNode {\n    \n\tint adjVen; // 边/弧指向哪个结点\n\n    ArcNode next; // 指向下一条弧的指针\n    \n}\n\n// 顶点\nclass VNode&lt;T&gt; {\n    \n\tT data;\n    \n    ArcNode first;\n    \n}\n\n// 邻接表存储的图\nclass ALGraph&lt;T&gt; {\n    \n\tVnode&lt;T&gt;[] vertices;\n    \n    int vexNum;\n    \n    int arcNum;\n    \n}\n十字链表空间复杂度: 如何找到指定顶点的所有出边? – 顺着绿色线路找如何找到指定顶点的所有入边? – 顺着橙色线路找十字链表只用于存储有向图\nclass ArcNode {\n\t\n    // 弧尾顶点编号\n    int tailVex;\n    \n    // 弧头顶点编号\n    int headVex;\n    \n    // 权值\n    int info;\n    \n    // 弧头相同的下一条弧\n    ArcNode hLink;\n    \n    // 弧尾相同的下一条弧\n    ArcNode tlink;\n    \n}\n\nclass VexNode&lt;T&gt; {\n    \n    // 数据域\n\tT data;\n    \n    // 该顶点作为弧头的第一条弧\n    ArcNode firstIn;\n    \n    // 该顶点作为弧尾的第一条弧\n    ArcNode firstOut;\n}\n邻接多重表\nclass EdgeNode {\n\t\n    // 边的两个顶点编号i, j\n    int i, j;\n    \n    // 权值\n    int info;\n    \n    // 依附于顶点i,j的下一条边\n    EdgeNode iLink, jLink;\n    \n}\n\nclass VertexNode {\n\t\n    // 数据域\n    int data;\n    \n    // 与该顶点相连的第一条边\n    EdgeNode firstEdge;\n    \n}\n图的遍历深度优先遍历(DFS)深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法DFS会尽可能深的搜索树的分支。当节点v的所在边都已被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这个过程一直进行到从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个源节点并重复以上过程，整个进程反复进行直到所有节点被访问为止。\n实现方法\n首先将根结点放入stack中\n从stack中取出第一个节点，并检验它是否为目标\n如果找到目标，则结束搜寻并回传结果\n否则将它某一个尚未检验的直接子节点加入stack中\n\n\n重复步骤2\n如果不存在未检测的直接子节点\n将上一级节点加入stack中\n重复步骤2\n\n\n若stack为空，表示整张图都检查过了代码实现package com.algorithm.datastruct;\n\nimport lombok.Data;\n\nimport java.util.*;\n\n@Data\npublic class Graph&lt;T extends Comparable&lt;T&gt;&gt; {\n\n    /**\n     * storage vertex\n     */\n    private List&lt;T&gt; vertexList;\n\n    /**\n     * storage adjacency matrix of the graph\n     */\n    private int[][] edges;\n\n    /**\n     * denotes the number of edges\n     */\n    private int numOfEdges;\n\n    /**\n     * record whether a node has been accessed\n     */\n    private boolean[] isVisited;\n\n    public Graph(int n) {\n        edges = new int[n][n];\n        vertexList = new ArrayList&lt;&gt;(n);\n        numOfEdges = 0;\n    }\n\n    /**\n     * add vertex to vertexList\n     *\n     * @param vertex vertex of graph\n     */\n    public void insertVertex(T vertex) {\n        vertexList.add(vertex);\n    }\n\n    /**\n     * add edge\n     *\n     * @param v1     index of first vertex\n     * @param v2     index of second vertex\n     * @param weight weight value of vertex\n     */\n    public void insertEdge(int v1, int v2, int weight) {\n        edges[v1][v2] = weight;\n        edges[v2][v1] = weight;\n        numOfEdges++;\n    }\n\n    public void show() {\n        for (int[] edge : edges) {\n            System.out.println(Arrays.toString(edge));\n        }\n    }\n\n    public T getValueByIndex(int i) {\n        return vertexList.get(i);\n    }\n\n    public int getWeight(int v1, int v2) {\n        return edges[v1][v2];\n    }\n\n    /**\n     * get the index of first adjacency vertex\n     *\n     * @param index index to be found\n     * @return success return index, failure return -1\n     */\n    public int getFirstNeighbor(int index) {\n        for (int i = 0; i &lt; vertexList.size(); i++) {\n            if (edges[index][i] &gt; 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * get the index of next adjacency vertex by the previous adjacency vertex\n     *\n     * @param v1 x of previous adjacency vertex\n     * @param v2 y of previous adjacency vertex\n     * @return success return index, failure return -1\n     */\n    public int getNextNeighbor(int v1, int v2) {\n        for (int i = v2 + 1; i &lt; vertexList.size(); i++) {\n            if (edges[v1][i] &gt; 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public void dfs(boolean[] isVisited, int i) {\n        System.out.print(getValueByIndex(i) + (i + 1 == vertexList.size() ? \"\" : \"-&gt;\"));\n        isVisited[i] = true;\n        int w = getFirstNeighbor(i);\n        while (w != -1) {\n            if (!isVisited[w]) {\n                dfs(isVisited, w);\n            }\n            w = getNextNeighbor(i, w);\n        }\n    }\n\n    public void dfs() {\n        isVisited = new boolean[vertexList.size()];\n        for (int i = 0; i &lt; vertexList.size(); i++) {\n            if (!isVisited[i]) {\n                dfs(isVisited, i);\n            }\n        }\n    }\n\n}\n\n广度优先遍历(BFS)广度优先搜索算法（英语：Breadth-First Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索演算法。BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。\n\n实现方法\n首先将根结点放入队列中\n从队列中取出第一个节点, 并检验它是否为目标\n如果找到目标, 则结束搜寻并回传结果\n否则将它所有尚未检验过的直接子节点加入队列中\n\n\n若队列为空, 表示整张图都检查过了 – 即图中没有欲搜寻的目标. 结束搜寻并返回null。\n重复步骤2代码实现public void bfs(boolean[] isVisited, int i) {\n    Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();\n    System.out.print(getValueByIndex(i) +  (i + 1 == vertexList.size() ? \"\" : \"=&gt;\"));\n    isVisited[i] = true;\n    queue.add(i);\n    // index of queue head node\n    int u;\n    // adjacency vertex\n    int w;\n    while (!queue.isEmpty()) {\n        u = queue.poll();\n        w = getFirstNeighbor(u);\n        while (w != -1) {\n            if (!isVisited[w]) {\n                System.out.print(getValueByIndex(w) + (w + 1 == vertexList.size() ? \"\" : \"=&gt;\"));\n                isVisited[w] = true;\n                queue.add(w);\n            }\n            w = getNextNeighbor(u, w);\n        }\n    }\n}\n\npublic void bfs() {\n    isVisited = new boolean[vertexList.size()];\n    for (int i = 0; i &lt; vertexList.size(); i++) {\n        if (!isVisited[i]) {\n            bfs(isVisited, i);\n        }\n    }\n}\n\n最小生成树(MST)最小生成树的概念最小生成树是一副连通加权无向图中一颗权值最小的生成树对于一个带权连通无向图, 生成树不同, 每棵树的权(即树种所有边上的权值之和)也可能不同. 设R为G的所有生成树的集合, 若T为R中边的权值之和最小的生成树, 则T称为G的最小生成树(Minimum-Spanning-Tree, MST)\n\n最小生成树可能有多个, 但边的权值之和总是唯一且最小的\n最小生成树的边数 = 顶点数 - 1。砍掉一条则不连通，增加一条边则会出现回路\n如果一个连通图本身就是一颗树，则其最小生成树就是它本身\n只有连通图才有生成树，非连通图只有生成森林\n\nPrim算法普里姆算法(Prim’s algorithm), 于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法算法描述: 从某一顶点开始构建生成树; 每次将代价(权值)最小的新顶点纳入生成树, 直到所有顶点都纳入为止时间复杂度: 适合用于边稠密图Prim算法可视化(即时实现)​\nKruskal算法Kruskal算法是一种用来查找最小生成树的算法, 由Joseph Kruskal在1956年发表算法描述: 每次选择一条权值最小的边, 使这条边的两头连通(原来已经连通的就不选), 直到所有结点都连通时间复杂度: 适合用于边稀疏图\n最短路径问题BFS算法Dijkstra算法Dijkstra（/ˈdikstrɑ/或/ˈdɛikstrɑ/）算法由荷兰计算机科学家 E. W. Dijkstra 于 1956 年发现，1959 年公开发表。是一种求解 非负权图 上单源最短路径的算法。\n流程将结点分为两个集合：已确定最短路长度的点集（记为集合）和未确定最短路长度的点集（记为集合）。一开始所有的点都属于集合。初始化，其他的均为。然后重复这些操作：\n\n从集合中，选取一个最短路长度最小的结点，移到集合中。\n对那些刚刚被加入集合的结点的所有出边执行松弛操作。\n\n直到T集合为空，算法结束。\n时间复杂度\n暴力：\n二叉堆：\n优先队列：\nFibonacci堆：\n线段树：代码实现\n\nFloyd算法有向无环图描述表达式拓扑排序关键路径","slug":"data-structure/图","date":"2022-01-12T11:37:25.000Z","categories_index":"数据结构","tags_index":"图论,考研","author_index":"Jx"},{"id":"10e799bf47669bd7fff35712248e1c6e","title":"2021年度总结","content":"\n\n前言写下此文的时候，2021已接近尾声，2022的钟声即将敲响，一年了，发生了什么呢，我又做成了什么呢…\n月度\n1月：创业园的师兄接到了个项目给我们做，起初这个项目叫维修小店，也就是做一个维修平台的小程序，于是学习了uni-app。\n2月：根据产品原型图写前端…\n3月：继续维修宝的前端；蓝桥杯选拔赛垫底orz\n4月：维修小店开发\n5月：维修小店改名为《维修宝》，这个月没少熬夜/通宵肝进度；学会了使用UniCloud实现微信支付/授权认证/…；在月末开始刷LeetCode了。\n6月：我干了什么..?\n7月：月初领到了《维修宝》杯水车薪工资，终于要结束了；月中学校的面向对象实训课，用Java网络编程的知识做了个基于TCP协议的聊天室；月末得知《维修宝》要大改，于是又开始了。\n8月：终于把王道考研的数据结构都过了遍，但有些还是一知半解；迭代《维修宝》。\n9月：LeetCode AC了100道题。\n10月：开始刷洛谷的题了，刷题、学习算法，一直循环\n11月：洛谷AC了100道题、AC了一道紫题、拿到了绿名；蓝桥的培训选拔赛，100个人参加，以第8名的成绩成功入围\n12月：蓝桥选拔赛以第11名的成绩成功获得公费资格；算法大赛校赛三等奖；月中师兄来了个项目，做跨境电商的；“传智杯”拿了个B组区域赛二等奖\n\n年度\n《维修宝》小程序项目\nUNI-APP\n微信的各种业务\n云开发\nVUE\nelement-ui\n\n\nLeetCode+洛谷 刷了200+道题\n算法大赛校赛三等奖\n“传智杯”B组程序设计大赛区域赛二等奖\n\n2022 TODO\n为上岸深圳技术大学做准备！！！\n尽快搞定跨境电商项目\n备赛3月WEB技能大赛\n备赛3月的蓝桥杯\n学习汇编\n学习408\n完成处心：Java后端\n减肥ww\n阿里云ACP认证\n\n平台出勤Gitee\nLeetCode\n洛谷\n\n","slug":"life/2021年度总结","date":"2021-12-31T12:25:41.000Z","categories_index":"生活","tags_index":"人生,2021,总结","author_index":"Jx"},{"id":"3f945107ce99195b9c8dafd2737a8d45","title":"How to Using FiddlerEverywhere","content":"\n\nFiddler EveryWhere 环境安装1. 安装Fiddler 功能强大，同时占用空间小，能记录所有的客户端和服务器端的 http 和https 请求，方便测试人员进行接口测试。官方下载地址：https://www.telerik.com/fiddler/fiddler-everywhere由于笔者使用的是Mac OS，而经典版的只支持Windows，所以我们这里下载最新版的Fiddler EveryWhere，安装步骤如下：\n\n打开下载好的Flddler Everywhere.dmg, 弹出如下界面，点击Agree同意\n\n\n图1 同意许可证协议\n\n\n将左侧Fiddler的LOGO拖拽到右侧的Applications文件夹即可完成安装\n\n\n图2 拖拽到Applications完成安装\n\n\n软件安装过程非常简单，读者可自行完成安装。笔者安装的 Fiddler Everywhere 为 3.0.1 版。安装完成后，启动 Fiddler Everywhere，出现如下图的欢迎界面（需要注册并登陆）。意思是你可以有三种方法去使用Fiddler：\n\n\nSystem Traffic Capturing（系统流量捕捉）\nPreconfigured Browser Capturing（预先配置的浏览器捕捉）\nDebug mobile devices（调试手机设备）\n\n\n图3 欢迎界面\n\n2. 使用程序界面如下图所示：图4 Fidder Everywhere界面示意图\n\n工具条：即选项卡，可以选择实时流量抓取区（Live Traffic）和对接口进行测试（Composer），Fiddler Everywhere 的 Composer 比较类似 Postman ，接口测试起来非常方便\n会话区：Fiddler Everywhere 捕获的流量会实时呈现在这里\n请求存储区：用于存储接口\n\n目前许多网站都会采用https 协议来进行传输，相比于 http 协议，主要是增加了传输加密和安全认证等功能，从而提高了传输的安全性。但需要注意的是，Fiddler 刚安装完成是并不能显示 https 协议的会话，需要进行相应的设置，并进行证书安装。Mac下操作步骤如下：\n\n进入设置\n\n图5 进入设置\n\nTrust root certificate，信任根证书，并勾选Capture HTTPS traffic和Ignore server certificate errors(unsafe)即可，如下图所示：\n\n图6 设置\n\n\n\n\n\n\n\n\n\n为什么要先学fiddler？学习接口测试必学http协议，如果直接先讲协议，为了更好的理解协议，先从抓包开始。结合抓包工具讲http协议更容易学一些。为什么使用Fiddler Everywhere而不是经典版的Fiddler？Fiddler Everywhere是一款跨平台（Windows、Mac、Linux）的Web调试代理工具，本文将用Mac系统进行演示\nFiddler Everywhere 的使用1. 证书问题为什么需要证书？先说结论：捕获HTTPS必须要导入Fiddler的证书。知道什么是证书之前需要了解下 “非对称加密”\n\n对称加密：客户端和服务器用一个秘钥加密和解密。对称加密效率高\n非对称加密：将公钥公布于众，客户端拿公钥加密，服务器拿自己的私钥解密，这样即使数据被截获，别人也解密不出明文内容。效率低。\n\n非对称加密有两个秘钥，公钥和私钥，而这两个秘钥只要用一个加密，另一个就能解密，我们正常加密数据用公钥加密，用私钥解密而我们还有一种用法就是服务器发数据用私钥加密，客户端用公钥解密，那么客户如果用公钥正确解密出数据，那么就证明这个数据一定是服务器发的，因为私钥只有它知道，这个过程我们一般不叫加密，叫签名，也就是服务器对数据签个名，代表这个确确实实是它发的。其实我们正常情况下因为对称加密效率虽高，但是不安全，因为它告诉对方秘钥的时候这个秘钥容易被截获，但是我们如果用非对称加密，安全是安全，效率又太低，所以一般采用对称加密来加密数据，非对称加密配送对称加密的秘钥。因为公钥是在网络上进行传输的，那么假如遭遇了如下图所示的中间人攻击，那么A的私钥就可能是伪造的。那么如何验证公钥的合法性呢？——证书\n什么是证书？证书就是由认证机构，采用它们自己的私钥，对发送方的公钥和发送方的信息进行数字加密。各大CA（认证机构）的证书已经默认被添加到了浏览器和操作系统中。服务器生成自己的密匙对——公钥和私钥服务器在认证机构注册自己的公钥认证机构（CA）用自己机构的私钥对，服务器的公钥进行数字签名并生成证书（里面带了这个签名过得公钥和服务器一些信息）认证机构把证书给客户端客户端用认证机构的公钥验证数字签名认证成功后用里面带的服务器的公钥加密并发消息给服务器服务器用自己的私钥解密这样一来就可以解决数据传输的安全问题了问题：\n\n如果黑客在服务器在认证机构注册公钥的时候截取数据呢？\n\n这个完全不用担心，CA证书的申请，流程很多，而且较为严格，比如准备很多文件，再比如CA那边如果通过后还会要申请方这边的管理员验证之类的。\n\n认证机构的公钥咋传输的？如果黑客改了呢？  如果改了那么这个证书就不会验证成功，其实各大CA的公钥已经在系统和浏览器中内置了。看下边的例子：\n\n百度的证书信息：系统自带的CA证书：\n抓包工具为什么需要导入证书？1.客户端发一个HTTPS请求，被Fiddler拦截并且Fiddler伪装成客户端发请求给服务器\n\n服务器向假装成客户端的FIddler返回了CA证书\n自己制作了一张证书，假装服务器给客户端发了自己做的证书。获取服务器的公钥\n客户端生成对称秘钥，并用Fiddler假冒的公钥加密发送\nFiddler用自己的私钥解密获取对称秘钥\n……这样的话Fiddler能完全获取解析到双方加密的数据。实验证明：当我们正常访问百度，查看证书：开启Fiddler后，我们再访问百度：\n\n安装根证书\n点击Trust root certificate （Mac会需要输入系统密码）\n勾选Capture HTTPS traffic\nSave保存即可安装成功，就可以开始抓HTTPS啦（可能需要重启Fiddler Everywhere）\n\n\n删除证书如果之前装过一些fiddler证书，安装的姿势不对，导致新的证书不起作用，这时候需要先删掉之前的证书了\n\n在启动台（Launchpad）的其他中找到钥匙串（Keychain Access），或者在聚焦搜索(spotlight search)中搜钥匙串(Keychain Access)也可以找到。\n\n\n\n我们可以在Default keychains -&gt; login -&gt; Certificerts 中可以找到Fiddler的根证书DO_NOT_TRUST_FiddlerRoot，右键即可删除。\n\n\n2. 手机APP抓包前言fiddler在抓手机app的请求时候，通常也会抓到来自PC的请求，导致会话消息太多，那么如何把来自pc的请求过滤掉，只抓来自APP的请求呢？必备环境：1.电脑上已装fiddler2.手机和电脑在同一局域网\n设置\nFiddler Everywhere -&gt; Settings -&gt; Connections，勾选Allow remote computers to connect\n8866端口为Fiddler的监听端口，后续手机中会用到。我这里的端口默认是8866，具体的端口号按实际情况来。\n\n\n查看本机IP打开终端（Terminal），输入ifconfig（Windows下为ipconfig），找到IP，如下图：\n手机设置代理\n手机设置-&gt;WLAN设置-&gt;选择该wifi，点右边的箭头（有的手机是长按弹出选项框）。\n将代理换为手动进行配置：\n配置主机名：与主机IP保持一致\n端口：8866（Fiddler的监听端口）\n\n\n保存后即可抓取手机上的请求了\n\n\n抓取HTTPS请求\n如果app都是http请求，是不需要安装证书，能直接抓到的，如果是https请求，这时候手机就需要下载证书了\n打开手机浏览器输入地址：[主机IP]:[Fiddler端口]，比如我这里是172.20.249.225:8866\n出现如下画面，点箭头所指的位置，点击安装就可以了。\n不同手机安装证书方法可能会有所差异\n\n\n3. 查看GET和POST请求前言前面讲了关于Fiddler Everywhere抓包的一些基本配置，配置完之后就可以抓到我们想要的数据了，接下来就是如何去分析这些数据。本篇以洛谷的请求为例，简单分析get与post数据有何不一样，以后也能分辨出哪些是get，哪些是post了。\nGET请求\n打开Fiddler Everywhere，然后浏览器输入洛谷首页地址：https://www.luogu.com.cn/\n点开右侧Inspectors下的Headers区域，查看Request Headers\nRequest Headers区域里面的就是请求头信息，可以看到打开洛谷首页的是get请求\n\n\nPOST请求\n打开登录首页：https://www.luogu.com.cn/auth/login\n输入账号和密码点击登录后，查看箭头所指的地方，可以看出是post请求\n\n\n如何找出需要的请求\n点开漏斗（Advanced Filters）\n\n\n\n比如我们要只抓洛谷的请求，那我们可以设置条件：url contains luogu.com.cn，如下图：\n\n\n\nAPPLY后即可只抓取洛谷的请求了\n\nGET和POST请求的区别\n关于get和post的功能上区别就不说了，大家自己查资料，这里主要从fiddler抓包的层面查看请求参数上的区别\nget请求的Raw参数查看，主要分三部分：\n\n\n第1部分是请求url地址\n第2部分是host地址\n第3部分是请求头部信息header\n\n\n再查看博客登录请求的Raw信息，post的信息分四部分。–前面3块内容都一样，第3部分和第4部分中间会空一行–第4部分内容就是post请求的请求body（get请求是没body的）\n\n\n4. 工具介绍本篇简单的介绍下fiddler界面的几块区域，以及各自区域到底是干什么用的，以便于更好的掌握这个工具\n会话框会话框主要查看请求的一些请求的一些基本信息，如# 、URL、HTTP Version、Result、Method、Process、Remote IP、Body Size、Comments，具体如下表：\n\n\n\n字段\n说明\n\n\n\n#\n这一栏是代表这个请求大概是什么内容\n\n\nURL\n请求的路径\n\n\nHTTP Version\nHTTP的版本，如HTTP/1.1\n\n\nResult\nHTTP状态码，如200(成功)、3xx（重定向相关）、4xx（找不到资源，一般是请求地址有问题）、5xx（一般是服务器本身的错误）\n\n\nMethod\n请求方法，如：GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、CONNECT\n\n\nProcess\n进程\n\n\nRemote IP\n远程IP\n\n\nBody Size\n请求产生的数据大小\n\n\nComments\n类似于备注，可以右键一个请求进行Comment\n\n\nRequest和Response\n\nRequest是客户端发出去的数据，Response是服务端返回过来的数据，这两块区域功能差不多\nheaders:请求头，这里包含client、cookies、transport等\nParams：请求时所带的参数\ncookies:查看cookie详情\nraw:查看一个完整请求的内容，可以直接复制\nbody：经过格式化后的主体\n\ndecode解码Fiddler Everywhere 会自动进行解码，无需再手动执行了\n5. 接口测试（Composer）前言Fiddler最大的优势在于抓包，我们大部分使用的功能也在抓包的功能上，fiddler做接口测试也是非常方便的。Fiddler Everywhere的Composer功能非常强大又简单易用，逐渐向Postman靠齐\nComposer简介点开右侧Composer区域，可以看到如下界面，就是测试接口的界面了\nJSON数据1.有些post的请求参数和返回参数是Json格式的，如洛谷的登录请求：https://www.luogu.com.cn/api/auth/userPassLogin2.在登录页面手动输入账号和密码，登录成功。3.找到这个登录成功的会话，查看json数据如下图：\n模拟GET请求\n在Composer区域地址栏输入博客首页：http://luogu.com.cn\n选择GET请求，点Execute执行，请求就可以发送成功啦\n请求成功下方的Response会生成会话记录，可以查看本条请求的响应详情\n\n\n模拟POST请求(实战登陆洛谷)这里的模拟POST请求我们以登陆洛谷为案例进行讲解。\n\n洛谷登陆链接：https://www.luogu.com.cn/auth/login如上图，洛谷的登陆需要输入用户名+密码+验证码才能登陆成功，从表面上来看，我们只需要两个接口就能登陆成功，一个是获取验证码的GET请求接口，一个是登陆的POST接口，先GET验证码，然后根据验证码加上我们的用户名和密码调用登陆接口进行登陆，但实际并非想象中的那么简单，以下为抓包流程：\n1. 过滤我们只需要抓取洛谷的接口，如下图，在Search栏输入洛谷的域名：luogu.com.cn，就只会抓取洛谷的请求了\n2. 抓取验证码接口在洛谷的登陆界面点击刷新验证码，抓到验证码的接口，可以在Response-&gt;Prieview中看到验证码的图像为了方便接口测试，我们右键这个验证码请求-&gt;点击Edit in Composer，如下图：可以发现接口的地址为：https://www.luogu.com.cn/api/verify/captcha?_t=1640680004860.4568。参数_t为时间，也就是距 1970 年 1 月 1 日之间的毫秒数，如下图：我们还可以将这个请求进行保存，点击EXCUTE旁边的SAVE，输入请求的名称，选择所在的文件夹，点击SAVE保存即可，如下图：\n3. 抓取登陆接口我们在洛谷输入正确的用户名、密码和验证码后点击登陆。在Fiddler中寻找刚才发送的登陆请求，由于我们已知洛谷的登陆请求为POST方法，所以可以根据Method排序去找POST请求。找到一个POST请求的Request区Body中有刚刚输入的账号/密码/验证码的信息，这个就是洛谷登陆接口了[https://www.luogu.com.cn/api/auth/userPassLogin](https://www.luogu.com.cn/api/auth/userPassLogin)，如下图：接下来我们还是跟步骤2一样存储一下这次的请求，右键登陆请求 -&gt; Edit in Composer，然后SAVE一下Request（我这边把请求名称取名为了“登陆”），现在我们左下角的的Requests区就有了两个请求：\n4. 测试登陆按照最初的想法，先调用验证码接口，查看到验证码：zn22然后使用zn22这个验证码加上我们自己的用户名密码去调用登陆接口，登陆请求的Body中有三个参数username、password、captcha分别对应着用户名、密码、验证码，这些我们根据实际情况去修改，如下图：修改完请求体后点击EXCUTE执行，响应体中给我们提示报错了，提示会话超时，请刷新页面后重试：出现这种类似的错误信息，原因一定出在请求的请求头中，服务器对请求头进行了限制，比如验证Cookies、和为了防止跨站攻击而设置的验证X-CSRF-TOKEN等，所以才会出现此类情况。接下来，分析POST登陆请求的请求头：\nHost:www.luogu.com.cn\nConnection:keep-alive\nContent-Length:82\nsec-ch-ua:\" Not A;Brand\";v=\"99\", \"Chromium\";v=\"96\", \"Google Chrome\";v=\"96\"\nX-CSRF-TOKEN:1640768448:U3hwS2h4azHVGgygSHLD9oaY7Z+4Bf9U8VwT1rWLEYQ=\nsec-ch-ua-mobile:?0\nUser-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36\nContent-Type:application/json\nAccept:application/json, text/plain, */*\nX-Requested-With:XMLHttpRequest\nsec-ch-ua-platform:\"macOS\"\nOrigin:https://www.luogu.com.cn\nSec-Fetch-Site:same-origin\nSec-Fetch-Mode:cors\nSec-Fetch-Dest:empty\nReferer:https://www.luogu.com.cn/auth/login\nAccept-Encoding:gzip, deflate, br\nAccept-Language:en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\nCookie:__client_id=d60b5430b77152d9bc168bca64ace8883254e127; _uid=0\n\n上述的请求头中，除了X-CSRF-TOKEN和Cookie其他都不需要变动。X-CSRF-TOKEN可以在GET https://www.luogu.com.cn/auth/login的Body中找到，如下图：而Cookes可以在Response -&gt; Cookies中找到，右键Value可以进行复制，如下图：知道了这两个是如何获取的就可以继续我们的测试登陆了，具体步骤也就变成了：\n\nGET https://www.luogu.com.cn/auth/login，获取到Cookies和X-CSRF-TOKEN，并记录下来。\n带上Cookies去GET https://www.luogu.com.cn/api/verify/captcha，记录下获取到的验证码。\nPOST https://www.luogu.com.cn/api/auth/userPassLogin：需要修改Headers中的Cookies和X-CSRF-TOKEN，请求体Body中的captcha参数更换为步骤二获取到的验证码。\n\n登陆成功如下图，就可以拿syncToken以及响应的Cookies去请求需要登陆的接口了。\nGET请求（URL详解）前言上一篇介绍了Composer的功能，可以模拟get和post请求，get请求有些是不带参数的，这种比较容易，直接放到url地址栏就行。有些get请求会带有参数，本篇详细介绍url地址格式。\nurl详解\nurl就是我们平常打开百度在地址栏输入的：https://www.baidu.com,如下图，这个是最简单的url地址，打开的是百度的主页\n再看一个稍微复杂一点的url，在百度输入框输入：洛谷\n\n\n\n查看url地址栏，对比之前的百度首页url地址，后面多了很多参数。当然最主要的参数是:wd=上海悠悠博客园（后面的一大串可以暂时忽略）\n那么问题来了，这些参数有什么作用呢？可以做个简单的对比，在地址栏分别输入：https://www.baidu.comhttps://www.baidu.com/s?wd=洛谷对比打开的页面有什么不一样，现在知道作用了吧，也就是说这个多的”/s？wd=洛谷”就是搜索的结果页面\n\nurl解析\n以https://www.baidu.com/s?wd=洛谷这个URL请求为例\n那么一个完整的url地址，基本格式：https://host:port/path?xxx=aaa&amp;ooo=bbb\n\n\nhttp/https：这个是协议类型，如图中所示\nhost:服务器的IP地址或者域名，如图中2所示\nport:HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如：192.168.3.111:8080，这里的8080就是端口\npath:访问资源的路径,如图中3所示/s (图中3是把path和请求参数放一起了)\n？:url里面的？这个符号是个分割线，用来区分问号前面的是path，问号后面的是参数\nurl-params:问号后面的是请求参数，格式：xxx=aaa，如图4区域就是请求参数\n&amp;：多个参数用&amp;符号连接\n\nUrlEncode编码\n如果url地址的参数带有中文的，一般在url里面会是这样的，如第二点里的wd=%E6%B4%9B%E8%B0%B7。像看到%B4这种编码的就是经过url编码过的，需要解码就能看到是什么中文了\n用urlencode在线编码/解码工具，地址：https://www.urldecoder.org/\n\n\n请求参数（params）\n在url里面请求参数一般叫params，每个参数对应的都有name和value值\n多个参数情况如下：\n\n\nPOST请求（body）前言上一篇讲过get请求的参数都在url里，post的请求相对于get请求多了个body部分，本篇就详细讲解下body部分参数的几种形式。注意：post请求的参数可以放在url，也可以放在body，也可以同时放在url和body，当然post请求也可以不带参数。只是一般来说，post请求的参数习惯放到body部分\nbody数据类型常见的post提交数据类型有四种：\n\n第一种：application/json：这是最常见的json格式，也是非常友好的深受小伙伴喜欢的一种，比如：\n\n{“input1”:”xxx”,”input2”:”ooo”,”remember”:false}\n\n\n第二种：application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数\n\ninput1=xxx&amp;input2=ooo&amp;remember=false\n\n\n第三种：multipart/form-data:这一种是表单格式的，数据类型如下：\n\nWebKitFormBoundaryrGKCBY7qhFd3TrwA \nContent-Disposition: form-data; \nname=”file”; \nfilename=”chrome.png” \nContent-Type: image/png PNG\ncontent of chrome.png \nWebKitFormBoundaryrGKCBY7qhFd3TrwA\n\n\n第四种：text/xml:这种直接传的xml格式\n\n&lt;!--?xml version=\"1.0\"?--&gt;\n&lt;methodcall&gt;\n\t&lt;methodname&gt;examples.getStateName&lt;/methodname&gt;\n\t&lt;params&gt;\n\t\t&lt;param&gt;\n\t\t\t&lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;\n\t\t&lt;/param&gt;\n\t&lt;/params&gt;\n&lt;/methodcall&gt;\n\nx-www-form-urlencoded浏览器的原生  表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：\nPOST http://www.example.com HTTP/1.1\nContent-Type: application/x-www-form-urlencoded;charset=utf-8\n\ntitle=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3\n\n首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，可以获取到的值，_POST[‘sub’] 可以得到 sub 数组。很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。\n6. HTTP协议简介什么是HTTP1.HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。2.HTTP（HyperText Transfer Protocol）协议是基于TCP的应用层协议，它不关心数据传输的细节，主要是用来规定客户端和服务端的数据传输格式，最初是用来向客户端传输HTML页面的内容。默认端口是803.http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议\n\n请求报文1.HTTP请求报文主要由请求行、请求头部、空一行、请求正文4部分组成（当然，如果不算空的一行，那就是3个部分）\n\n2.下图是fiddler工具抓的post请求报文（工具使用看fiddler篇），可以对照上图，更清楚的理解http的请求报文内容。\n\n响应报文1.HTTP响应报文主要由状态行、消息报头、空一行、响应正文4部分组成（当然，如果不算空的一行，那就是3个部分）2.下图就是一个请求的响应内容，用fiddler抓包工具可以查看\n完整的HTTP内容\n一个完整的http协议其实就两块内容，一个是发的请求，一个服务端给的响应。\n以下是请求https://github.com/timeline.json 这个地址后，用fiddler抓包导出为文本，查看完整的http请求内容。（具体操作查看《fiddler 1.10会话保存》）\n\n内容如下：以下是请求报文\nGET https://github.com/timeline.json HTTP/1.1\nHost: github.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\nAccept-Encoding: gzip, deflate, br\nCookie: xxx(已省略)\n\n以下是请求报文\nGET https://github.com/timeline.json HTTP/1.1\nHost: github.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\nAccept-Encoding: gzip, deflate, br\nCookie: xxx(已省略)\nX-Request-Id: d09e199dc290c6f0dc79fe49007069ab\nX-Runtime: 0.004161\nContent-Security-Policy: xxx(已省略)\nStrict-Transport-Security: xxx(已省略)\nX-Content-Type-Options: nosniff\nX-Frame-Options: deny\nX-XSS-Protection: 1; mode=block\nX-Runtime-rack: 0.007388\nX-GitHub-Request-Id: FE36:2B0A9:177175F:23C092D:594FD998\nContent-Length: 379\n\n以下是响应正文（json格式）\n{“message”:”Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.”,”documentation_url”:”https://developer.github.com/v3/activity/events/#list-public-events”}\n\n请求行8种请求行请求行有三个主要参数：请求方法、url、协议版本。\n请求方法请求方式简介get请求指定的页面信息，并返回实体主体。post向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性PUT向指定资源位置上传其最新内容DELETE请求服务器删除Request-URL所标识的资源TRACE回显服务器收到的请求，主要用于测试或诊断CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。\n\n注意：1）方法名称是区分大小写的。2）最常见的的就是通常说的get和post方法。\n\nurl详解1.打开百度，在搜索框输入任意文字，搜索后，复制地址栏的url地址：\nhttps://www.baidu.com/s?wd=%E4%B8%8A%E6%B5%B7%E6%82%A0%E6%82%A0%E5%8D%9A%E5%AE%A2&amp;rsv_spt=1&amp;rsv_iqid=0x91baaabd00070ba2&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2\n\n2.那么一个完整的url地址，基本格式如下：\nhttps://host:port/path?xxx=aaa&amp;ooo=bbb\n\n\nhttp/https：这个是协议类型，如图中1所示\nhost:服务器的IP地址或者域名，如图中2所示\nport:HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如：192.168.3.111:8080，这里的8080就是端口\npath:访问资源的路径,如图中3所示/s (图中3是把path和请求参数放一起了)\n？:url里面的？这个符号是个分割线，用来区分问号前面的是path，问号后面的是参数\nurl-params:问号后面的是请求参数，格式：xxx=aaa，如图4区域就是请求参数\n&amp;：多个参数用&amp;符号连接\n\n协议版本根据HTTP标准，HTTP请求可以使用多种请求方法。HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n","slug":"testing/Fiddler Everywhere抓包","date":"2021-12-30T02:43:04.000Z","categories_index":"测试","tags_index":"软件测试","author_index":"Jx"},{"id":"2cc8b90b0dba95b11728dd29144d57a6","title":"《软件开发工具》","content":"\n\n第1章 绪论软件产品的质量、效率、价格已成为各方关注的十分重要的问题。\n1.1 软件开发工具的由来\n操作系统、汇编程序、汇编系统时软件开发中必不可少的工具，但一般不把他们归入软件开发工具的范围，类似的还有磁盘的处理、病毒的防治、系统的备份等。\n\n软件开发工具的范围（概念）：在高级程序设计语言（第三代语言）的基础上，为提高软件开发的质量和效率，从规划、分析、设计、测试、文档和管理等方面，对软件开发者提供各种不同程度的帮助的一类新型的软件\n\n第一代计算机语言（机器语言）：由0和1组成的字符串\n\n第二代计算机语言（汇编语言）：针对难记忆、无意义的二进制字符串，人们试图用英语中具有一定意义的单词（或单词的缩写）来代替它，这就是 “助记忆码”或汇编码,用汇编编写的程序叫汇编程序，而把这些汇编程序转换成机器指令的程序则称为汇编系统（Assembler）。至今，汇编语言还是计算机专业人员必须学习的基本知识之一。\n\n操作系统差不多与汇编语言同时出现（20世纪50年代末60年代初）：\n\n操作系统的出现改善了人们应用计算机的条件。操作系统利用计算机本身能迅速处理信息的优势\n\n\n\n自动地完成系统初始化、文件管理、内存管理、作业管理、处理机管理等一系列工作\n这改善了计算机的使用环境，也同样对计算机应用的前进发挥了十分重要的作用\n\n\n第三代计算机语言（过程化语言）：在第三代语言的应用中，人们又发现了新的瓶颈–处理过程的描述\n\n第四代计算机语言（非过程化语言）：非过程化语言的思想是只要给机器下达做什么的命令，由机器自己去安排执行的顺序。在认识到软件工作的重要性的同时，也认识到了软件工作的困难性，这就是“软件危机”的问题\n\n硬件是计算机的躯体，软件是计算机的灵魂\n\n软件是广大使用者与计算机之间的桥梁\n\n软件是人类在各个领域中积累的知识的结晶\n\n软件是人类文明与知识得以延续的新的载体\n\n客观世界的复杂性，决定了软件本身的复杂性，人类知识的丰富多彩决定了软件的极大多样性；客观世界的动态性，决定了软件对可维护性、可重用性越来越高的要求。保证它的正确性、可靠性、如何控制软件开发工作的进度与成本，很自然地称为理论上十分重要、实际中十分迫切的课题。\n\n克服软件危机的方法(新技术)：\n\n\n结构化程序语言\n软件工程学\n面向对象的程序设计方法\n即插即用的程序设计方法（Plug and Play Programming）\n面向开源软件和互联网的程序设计\n\n\n用通用软件(如早期的WORDSTAR)帮助软件开发的主要弱点：\n\n\n有许多工作是通用软件无法完成的\n通用软件完成某些工作，只能表现出其表面的形式，而不能反映其逻辑内涵\n通用软件来帮助人们完成软件开发工作时，常常遇到难以保持一致性的困难\n\n\n\n针对以上问题，20世纪80年代以来，一些专门用于支持软件开发的软件开发工具陆续问世，从而进入专用的软件开发工具的阶段。如以下几类：\n\n\n面向特定功能模块的各种代码生成程序（包括报表生成器、菜单生成器、对话生成器等）\n综合性的第四代语言\n专用于某种文档的编写工具\n数据字典管理系统（DDMS）\n专用于画数据流程图、E-R图或程序框图的绘图软件等\n\n\n1989年，IBM公司宣布了一个名为AD/Cycle的巨大的理论框架（一体化环境开始，里程碑）\n\n\n缺点：\n\n\n拘泥于集中式的处理思路，对于新兴起的客户、服务器结构没有及时跟上\n坚持在OS/400等自己、特定的硬件平台上开发，背离了开放型的大趋势\n\n\n\n但是集成的软件开发环境的研发并没有因此停滞，例如Rational公司推出了Objectory，Rose等集成的软件开发工具\n\n21世纪以来，软件开发工具的发展也进入了新的阶段。两个鲜明的特点使软件开发工具的功能和效率提高了一个新的阶段：\n\n\n面向网络，不仅基于网络，而且用于网络。从HTML到XML，从SOAP到UDDL\n软件开发越来越需要考虑互联网上的应用，越来越注意要再网络环境下使用\n\n\n\n开源软件的兴起和运用\n开源软件开发工作效率地提供是肯定有益的\n\n\n\n1.2 软件开发工具的概念软件开发工具的概念要点:\n\n它是在**高级程序设计语言(第三代语言)**之后，软件技术进一步发展的产物\n它的目的是在人们开发软件中给予各种不同方面、不同程度的支持或帮助\n它支持软件开发的全过程，而不是仅限于编码或其他稳定的工作阶段\n\n在理解这个概念时,应同时认识软件开发工具的继承性与创新性。它的基本思想仍是致力于软件开发的高效优质\n\n硬件（Hardware）是躯体，软件（Software）是灵魂，二者缺一不可。软件一端连着计算机硬件，向硬件提供可以执行的机器指令，另一端面向用户\n软件是用户与硬件之间的桥梁\n软件实际上是人类知识与经验的结晶。所谓事先编好的指令，正是人们在实践中形成的工作规范与步骤\n当人们把程序编制出来时，已经为这些经验或理论知识找到了一种新的载体\n\n软件开发过程的实质： 知识的提炼、表述、固化\n软件开发新特点：\n\n自动化程度的提高\n这一阶段的工作明确地把需求分析和架构设计包括在软件工作的范围之内\n把软件开发工作延伸到项目及版本管理，从而超出了一次编程的局限\n在这一阶段的研究中，吸收了许多管理科学的内容与方法。在这方面卡内基·梅隆大学的软件工程研究所提出的能力成熟度模型（Capacity Morality Model-CMM）具有重要的意义\n\n总之，软件开发工具的提出与使用，是软件技术发展的一个新的阶段。\n与软件开发工具的概念术语有很多，如：\n\n第四代语言\n第四代语言系统通过某些标准处理过程的自动生成，使得用户可以只说明要求做什么，而把具体的执行步骤的安排交由软件自动处理\n\nCASE工具\n\n\nCASE工具有两种理解。一种是计算机辅助软件工程（Computer Aided Software Engineering），另一种则是计算机辅助系统工程（Computer Aided System Engineering）\n无论按哪种理解, 它的基本思想与软件开发工具是完全一致的,即应用计算机自身处理信息的巨大能力,帮助人们开发复杂的软件或应用系统\n\n可视化程序设计（Visual Programming）\n\n最终用户计算（End User Computing）\n\n组件程序设计（Component Programming）\n\n即插即用的程序设计（Plug and Play Programming）\n\n\n1.3 软件开发工具的功能与性能1. 软件开发的过程第一阶段 - 需求分析:\n软件开发工作首要的任务是根据这种初始要求形成严格的、明确的、可供实际开发使用的功能说明书。\n软件设计者需要从初始要求出发、经过大量的调查研究工作，抽象出应用领域中的实际的信息需求，设计出计算机系统内外的、合理的信息流程，并规定出软件系统的功能与性能要求。\n这些调查分析的成果集中体现在第一个重要文档–软件功能说明书\n第二阶段 - 总体设计：\n软件的结构设计、公用的数据文件或数据库的设计、各部分的连接方式及信息交换的标准\n总体设计的成果是系统的总体设计文件及各个模块的设计任务书。总体设计文件应包括结构图、模块清单、公用数据结构\n第三阶段 - 实现阶段（Coding）:程序的编写与文档的编写是两件并行的工作\n第四阶段 - 测试或调试阶段：其中包括模块的调试与整个软件的联调两个部分\n2. 软件开发工具的功能要求\n\n认识与描述客观系统： 主要用于需求分析阶段\n存储及管理开发过程中的信息\n代码的编写或生成\n文档的编制或生成\n软件项目的管理: 这方面的功能更明确地是为项目管理人员提供支持, 项目管理包括进度管理、资源与费用管理、质量管理三个基本内容\n\n\n\n3. 软件开发工具的性能对于软件开发工具来说以下五项应是特别重要的:\n\n表达能力或描述能力\n保持信息一致性的能力\n使用的方便程度\n工具的可靠程度: 即在各种各样的干扰下仍能保持正常工作,而不导致丢失或弄错信息\n 对硬件和软件环境的要求: 一般来说, 软件开发工具对环境的要求不应当超出它所支持的应用软件的环境要求, 有时甚至还应当低于应用软件的环境要求\n\n1.4 软件开发工具的类别1. 按工作阶段划分可以把软件开发工具分为三类：计划工具(出现最晚)、分析工具、设计工具(出现最早)\n各种代码生成器、一般所说的第四代语言及帮助人们进行测试的工具，都属于设计工具\n分析工具主要指用于支持需求分析的工具，如帮助人们编写数据字典的、专用的数据字典管理系统工具-FLOW，帮助人们画系统结构图或E-R图的工具等。保持信息的一致性，在这类工具中具有十分重要的地位\n计划工具则是完全为项目主管人员服务的\n2. 按集成程度划分专用的、面对某一工作阶段或某一工作任务的工具，以及集成化的、面对软件开发的全过程的工具\n集成化的软件开发工具也常常被称为软件工作环境（是指支持全过程、全阶段的软件开发工具）。\n3. 按与硬件、软件的关系划分有点软件开发工具依赖于特定的计算机或特定的软件（如某种数据库管理系统），有的则是独立于硬件与其他软件的。\n设计工具多是依赖于特定软件的\n分析工具与计划工具往往是独立于机器与软件的\n集成化的软件开发工具又常常是依赖于机器与软件的\n1.5 软件开发工具的研究与使用软件开发工具的使用者：\n\n从计算机专业出身的技术人员\n来自各个应用领域，他们出身于计算机以外的各个专业领域，如会计、金融、工程、企业管理等\n\n第2章 软件开发过程及其组织软件危机源于客观世界，大系统的复杂性，规模越来越大\n如何克服软件危机: 1. 结构化程序设计方法 2. 软件工程方法 3. 面向对象的程序设计方法 4.即插即用的程序设计方法 5.面向开源软件和互联网平台的程序设计\n两个领域的问题需要特别注意: 1.软件质量的评价与改善问题 2.项目组管理的任务与方法。这两者与软件开发工作也是有直接联系的\n2.1 软件开发的困难软件的复杂性超出了人类的处理能力\n1. 软件开发的基本问题两个转换没有顺利地通过。首先是从用户的理解到程序员的理解，其次是从程序员的理解到程序的理解\n\n\n第一个转换是用户对软件功能的理解与程序员对软件功能的理解之间的转换\n程序员必须花相当的时间尽可能地了解与熟悉应用领域, 并且正确地理解用户工作中的信息需求和信息流程\n保证这一顺利完成的手段就是利用尽可能的标准化的方法编写程序设计任务书, 用明确的语言或图形、表格，把程序要处理的信息的内容、格式、来源、去向、存储与处理清楚地表达出来，作为双方共同的理解\n\n\n第二个转换所要解决的是人和机器之间的交流与协调问题, 这个转换关键在于程序员的知识水平和实际经验\n\n2. 大型软件开发中的困难\n一致性的保持称为十分困难的问题\n\n测试的困难大大增加\n\n水波效应: 人们修改程序的某一处时, 由于没有充分考虑这一修改对相关部分带来的影响, 结果出现了新的错误\n每个程序员只了解自己的一部分, 无法全面地预测自己的任何改动对其他部分的影响, 而项目负责人也不可能深入每一个细节中, 只能采用所谓的”黑箱“检验方法。这种检验只能证明程序有错而不能证明程序无错\n\n\n工作进度难以控制\n\n单个程序员常常过低估计工作难度而拖延进度\n对整个系统进行联调, 联调后发现问题回到程序员手中的修改, 反复多少次是无法事前判断的\n\n\n文档与代码的协调十分困难\n\n我们所说的文档包括: 功能说明书、总体设计、各模块的设计任务书、每个部分的研制报告、测试报告、直到最终的验收报告和给使用者的用户手册\n\n代码与文档必须一致，否则文档不仅没有用处，反而会造成混乱\n\n版本更新带来的困难\n\n版本更新的大量工作往往在于审核与回顾，包括对代码和文档两个方面的认真检查\n\n\n3. 困难产生的原因\n这些困难来自大系统的复杂性\n许多具有主动性的个人之间的组织与协调带来大量的困难\n各个应用领域之间的差别导致困难的加重\n时间的因素，变化的因素给软件开发工作带来许多困难\n\n2.2 软件开发方法的发展大型软件开发过程的各种角色:\n\n用户\n\n\n提出需求\n验收\n使用\n需求修改\n\n\n项目负责人(或软件架构师)\n\n\n分析需求(包括设计方案的形式)\n向程序员分配任务\n验收程序员的工作成果–代码与文档\n对整个软件进行联调\n向用户交付使用\n接收与分析用户的修改要求\n向程序员布置修改任务\n验收修改成果并向用户提交新的版本或修改的结果\n\n\n程序员\n\n\n编写程序\n编写文档\n调试自己编码的程序\n向项目负责人提交工作成果\n\n\n硬件\n\n\n1. 结构化程序设计方法好的程序结构的各种看法: \n\n它能够保证程序正常地，按照功能说明书运行\n它具有灵活性，没有错误，即使有了错误也能够很快地改正\n它的文档齐全，一旦需要变更，很容易找到应当改动的地方\n它运行速度快\n它在经济上能够保证投资很快地得到回报\n\n程序的结构分解成三种基本模块（避免“水波效应”）：\n\n处理单元\n循环机制\n二分决策机制 \n\n模块的划分应当符合以下三条基本的要求:\n\n凝聚性强：模块的功能在逻辑上尽可能地单一化、明确化，最好做到一一对应\n低耦合：模块之间的联系及互相影响尽可能的少，尽量避免逻辑耦合，而仅限于数据耦合\n模块的规模应当足够小，以便使它本身的调试易于进行\n\n结构化程序设计的实施要点:\n\n限制甚至不用GOTO语句，绝对禁止超越模块边界的GOTO语句\n子程序（也叫方法或函数）尽可能做到只有一个入口和出口\n程序风格应尽量明确、清晰，包括适当增加注释\n在程序编写的同时完成有关的文档编撰，不要拖延时间\n\n结构程序设计的方法是为程序员服务的，而对于项目负责人来说，则较少涉及他所关心的问题。对于这种方法的批评意见是增大了程序工作量，增加了编程中的麻烦与繁琐的工作，并且降低了程序的运行效率。\n为了保证软件的可靠、准确与易于修改，这种代价是值得的\n2. 软件工程方法根据经典的辞书《简明不列颠百科全书》，工程指的是“应用科学知识使自然资源最佳地为人类服务的一种专门技术”。工程的观点是和近代、现代的大生产联系在一起的，它是和依靠个人技艺的手工的生产方式相对立的\n软件工程的思想和方法:\n\n把软件的质量寄托于各个程序员的技能与认真负责是不牢靠的、危险的、不现实的\n要想从根本上提高软件开发的效率和质量，就应当吸取人们在各种传统产业中的成功经验\n从组织和管理的角度加强力量\n使软件生产从程序员的个人劳动提高到有组织的、可控制的工程\n\n软件工程从传统产业中吸取的经验：\n\n它们在多年实践的基础上，对于这项工作的步骤做出了严格的规定\n顺序绝对不能颠倒\n每一个阶段都有各自的明确的任务\n在质量、表达方式等方面要有统一\n它们作为有关各方沟通与交流的手段，使参加工作的不同职务、不同角色的人们成为一个整体，共同地完成一项大的工程任务\n\nIBM提出的AD/Cycle中，对于应用软件的开发过程作了如下的划分和规定：\n第一阶段：需求分析\n第二阶段：分析与设计阶段\n第三阶段：编程阶段\n第四阶段：测试阶段\n第五阶段：使用及维护阶段\n在标准化方面（如著名的ISO 9001标准等），人们主要从2个方面去探索：\n\n表达方式的标准化\n对工作的质量及检查制定标准\n\n软件工程的思想主要集中于加强项目管理者的工作上，对于程序员关系不大，这点与结构化程序设计方法正好互相补充。\n3. 面向对象的程序设计方法面向对象的程序设计(Object Oriented Programming–OOP)\n“面向对象”（Object Oriented）这个用于有多种不同的翻译方法，如“面向客体”、“面向目标”、“物件导向”\n“Object”的由来：把信息的静态属性(数据结构)和对它的处理(功能模块)从根本上结合起来，数据库(数据结构)和功能的矛盾和冲突就迎刃而解了\n20世纪70年代，Smalltalk语言的出现 ，使人们对这种思想的作用刮目相看。这种与众不同的语言把一切事物都看做Object，仅用三个最基本的语句（new，send，get）来表明对象的生成、送出消息、得到消息，而把一切动作都作为对象接到信息的反应，通过一套巧妙的递归嵌套，可以发展出任意的、复杂的结构。当C语言接受了这种思想后，发展出C++后，面向对象的思想成为普遍的潮流 \n面向对象的程序设计的基本思想：\n\n客观世界的任何事物都是对象，它们都有一些静态属性（相当于数据结构），也都有一些相关的操作（相当于程序模块或方法）。作为一个整体，对象对外不必公开这些属性与操作。这就是所谓的“封装性”（Encapsulation）\n对象之间有抽象与具体\n抽象的、较大的对象所具有的性质，包括静态属性和动态操作，自然地成为它的子类的性质，不必加以说明或规定。这就是所谓的“遗传”（Inheritance）\n对象之间可以互送消息(Message)。这消息可以是传送有一个参数\n\n面向对象的程序设计之所以能产生巨大的影响，其根本原因在于它提供了认识框架。也正因为这样，认识框架迅速地散步到程序设计语言的范围之外，以至出现了面向对象的系统分析（OOA）,面向对象的系统设计（OOD)，面向对象的数据库管理系统（ODBMS）\n4. 即插即用的程序设计方法与即插即用紧密相关的还有组件程序设计(Component Programming)，组合文件（Compound Document），宏观程序设计（Macro Programming）等，这是在面向对象的程序设计方法的基础上提出来的\n一部分人专门生产软件组件（相当于芯片），而另一部分人构造整个软件的结构（相当于计算机结构），并且把软件组件插入这个结构，以便迅速地完成大型软件的研制工作。这就是即插即用的意思\n实现的困难:\n\n标准化的问题十分困难\n软件部件的提供方式\n存在多种硬件、多种操作系统\n\n一些软件公司或机构在这方面作了不少探索，并已经在标准化方面提出了方案，如注明的CORBA（Common Object Request Broker Architeeture），就是一种公用的对象需求的转换结构，还有COM101（Common Object Model 101）等 \n5. 面向开源软件的程序设计方法随着开源软件（Open Source）的出现和发展，利用开源软件进行程序设计，已经成为越来越普遍的方法。对于开源软件，社会上和学术界有不同的看法。支持者认为这实现了软件的重用，能够大大提高软件生产的效率，是一种革命性的进步\n在一些应用面广，流程比较清晰，比较规范的应用领域，开源代码的重用是比较有把握的。\n使用开源代码并不一定会减轻工作量。实际上这对于软件开发人员，特别是项目负责人或软件系统的架构师来说，要求更高、更难。\n2.3 软件开发过程的管理一般来说，项目管理的要素是进度、质量、费用（开支）、资源利用。对于软件开发来说，核心是质量问题\n1. 什么样的软件才是好的软件?\n正确地实现所要求的功能，准确地给出预定的输出结果\n用户界面友好，符合实际用户的使用习惯于知识能力\n具有足够的速度（而不是越快越好），能在符合用户要求的时间额度内，给出所要求的处理结果\n具有足够的可靠性，能够在各种干扰下保持正常的工作\n程序易读，结构良好，文档齐全，从而保证系统易于修改\n\n2. 好的程序员与好的项目组就单个程序员来说，主要的指标包括以下几个方面：\n\n具有程序设计所需要的基本知识与技能，如关于数理逻辑的知识与训练，关于各类数据结构的概念及处理方法等\n对本项目所在的领域有较深入的了解，从而能够准确地理解用户的信息需求，正确地把握有关的信息流程与信息处理原则\n对于软件开发的技术环境比较熟悉，包括硬件设备、软件环境和网络环境。特别是对于所用的语言，应当有足够的、实际运用的经验\n\n就规模超出单个程序员的工作量的大型软件来说：\n\n保证严格地在本模块范围内操作，绝不使用可能干扰其他模块的命令或函数\n严格按总体设计的要求和理解去传递参数值，绝不随意修改其内容或含义\n在对公用的文件或数据库进行存取时，必须完全地、准确地统一规定的格式去操作，决不能擅自改变 \n在使用标识符时，应按照统一的原则，尽量使用易于看出逻辑含义的名称。\n严格按照统一的要求编写文档，在内容、格式、表达方式、符号使用上遵循项目组的统一规定\n尽量保持程序风格的统一，如注释行的安排，行末空格的使用等。\n\n3. 怎样建立一个好的项目组?根据CMM模型及其他一些材料，一个好的项目组至少具备以下几个条件：\n\n有严格的、成文的工作规范和文档标准，而且应当为全体成员所熟知，并且切实得到遵守\n人员之间有严格的分工，除了程序员之外，必须有专门的秘书（负责文档的收集、审核及保管）\n每个项目都要事先制定详细的时间表，并且得到严格执行。每一项目完成之后都有完整的资料，并得到妥善保存\n\n第3章 软件开发工具的理论基础软件开发工具的目的十分明确，就是从信息管理与信息处理方面，给软件开发人员提供支持与帮助\n本章重点阐述概念模式、信息库（或称为中心库）、人机界面以及项目管理\n3.1 软件开发过程的信息需求软件开发过程的信息：\n\n有关系统环境、现状及需求的信息。此类信息由用户提出\n有关软件的功能设计与物理设计的各种信息。这类信息是由分析人员（或设计人员）根据需求分析而形成的，它体现为设计方案\n软件成果本身，包括程序与文档。程序代码必然是在计算机内的，文档也常常以联机方式提供\n用户对系统的各种变更要求，以及系统的各种变更的记录。而这类信息是跨软件开发周期的\n\n围绕以上四类信息，涉及的信息管理工作有以下几方面：\n\n许多信息需要长期保存，因为它们并非只用一次，而是需要不断更新，不断被调用\n在许多环节上都要进行数据的转换或加工\n大量的人与人之间的信息交流\n\n软件开发工具正是为上述四类信息的合理存储、正确转化和顺畅流通提供帮助\n软件开发工具用到的比较重要的理论和方法:\n\n**认知科学(Cognitive Science)中关于概念模式(Conceptual Model)**的概念与方法\n数据库技术的理论与方法\n编译技术的有关方法\n关于人机界面的理论与方法\n管理科学中关于项目管理与版本管理的理论与方法\n系统科学与系统工程中的有关理论与方法\n\n3.2 概念模式及其作用Conceptual Model概念模式 ,也译为概念模型。它指人们在认识事物过程中，对于某一事物或某一系统形成的、抽象的、一般化的框架。这种概念模式具有主观性\n概念模式是人们认识客观世界的一种方法，一种工具\n概念模式是人们在长期的实践活动中逐渐形成的\n\n从上图中可以看出概念模式总是在一定理论、思想指导之下形成的，同时又不断地根据实际情况修正\n概念模式在认识中的作用十分重要，同时作为交流与表达工具也是十分重要的\n如何评价概念模式:\n概念模式的意义决定了它的相对性，即面对各种不同的用途，必然会有不同的形式的概念模式。一般来说，它们是各有各的用处，不能互相代替，也无法一般地说哪个更好或更有利。对于有一定的应用领域而言，如果有多种概念模式，则可以从它的表达能力，是否方便易用，是否严格，有没有二义性（容易引起误解）等方面进行评价和比较\n作为表达与交流的工具，必须简单明了、易于理解\n正确理解、掌握和运用概念模式，是做好软件开发工作的基础，也是掌握和运用软件开发工具的基础\n常见的概念模式有以下:\n\n框图(Flow Chart)\n框图是人们编写软件时用的最早的一种概念模式,用来描述程序执行的逻辑过程。\n当软件规模不太大时，它比较适用\n\n\n\n\n\n结构图(Structure Chart)又叫模块结构图\n\n它的观点是,程序的调用方式有三种: 顺序调用、选择调用、循环调用\n\n数据流程图(Data Flow Diagram)\n\n简称DFD\n面对的是一个系统的信息流程\n它更多地用于描述某一业务处理系统的信息来源、存储、处理、去向的全面情况\n基本思想是把信息流看成一个组织或系统运作的线索，力图简明扼要地勾画出全局\n和结构图相比，它更适用于客观描述\n\n\n实体关系图(Entity-Relationship Diagram)\n\n简称E-R图\n用于描述静态数据结构的概念模式\n它以实体、关系、属性三个基本概念概括数据的基本结构\n广泛应用于数据库的设计中\n\n\n**数据字典(**Data Dictionary)\n\n简称DD\n描述数据内容的概念模式\n\n\n时序网络(Petri Net)\n\n它主要描述系统状态及其转换方式\n常用于一些实时控制方面的软件的功能描述\n\n\n数学与逻辑模型\n\n作为逻辑模型的表达方式，决策树和决策表也是经常使用的\n\n\n计算机模拟模型\n\n计算机模拟是一种强有力的概念模式\n利用计算机大量、高速处理信息的能力，在计算机内设置一定的环境（如资源条件等），又以程序来实现客观系统中的某些规律或规则，在二者基础上，计算机就可以高速运行，以便人们观察与预测客观系统的状况软件开发的质量与效率可以由此得到很大的提高。在此基础上，软件开发工具进一步用计算机来帮助人们使用和实现这些概念模式，使软件开发工作提高一步\n\n\n\n3.3 信息库及其一致性信息库（Repository）译法不统一，有的专家译为中心库、总库、主库等。实际上，从它原义来说，无非就是数据库。但他不同于Database或Data Warehouse\nDatabase是在文件系统基础上发展起来的一种数据管理技术，它的重点在于合理地组织数据，体现出数据之间的逻辑关系，并尽可能地帮助用户检索，减少冗余。\n而数据仓库(Data Warehouse)是近年来针对大批数据的分析利用而提出来的概念。它的基本思想是：现实中的大量原始数据与实际的应用是有相当距离的，为了能够切实为企业管理者提出对管理真正有用的信息，就要对信息或数据进行多次的加工或提炼，从而得出许多派生的或综合的数据\n信息库的特点：信息库是一个包罗万象的，随着项目进度不断修改与补充的数据集合。作为软件开发全过程的信息管理总枢纽，它的数据结构是相当复杂的，而且会随着时间不断变化，因此保持一致性的任务变得十分复杂和艰巨。\n信息库的研究主要在以下方面:\n\n信息库的内容应当包括哪些方面\n所述软件的工作环境、功能需求、性能要求、有关的各种信息来源的状况、用户状况、硬件环境以及在该专业领域中的作用等外部信息\n需求分析阶段中收集的有关用户的各种信息，包括用户本身提供的\n逻辑设计阶段的各种调查材料和由此生成的各种文档，包括调查记录 、原始数据、报表及单证的样本、绘制的各种图以及最后生成的系统说明书\n编程阶段的所有成果，包括程序代码、框图、变量说明、测试情况（测试数据及输出结果）、验收报告、使用说明等。\n运行及使用情况的详细记录\n维护及修改的情况\n项目管理的有关信息、人员变更、资金投入、进度计划及实施情况。还包括版本信息\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n信息库应当具备哪些管理功能\n需要把计算机内外的信息存储统一起来管理\n信息库面对 分析人员、程序员和维护人员（一般不直接面对用户）等不同的对象，由于他们各有各的权限和使用目标，所以除了规定复杂的内部结构以存放信息外，还需要认真设计有关的界面\n\n\n如何保持一致性\n由于软件环境、需求以及它本身都在不断变化，信息库中的信息需要不断更新\n这里说的更新与一般的更新不同，信息库中的内容一般不删除，当有新的信息需要存入时，旧的信息只是加上时间标志移入历史信息中去，并且它还与新的信息保持着历史的、逻辑的联系\n一个模块的更新往往带来其他模块的相应变更，并不是一个模块更新后就能够自然而然地与其他模块一起构成一个新的版本\n对于一些国际性的大软件公司来说，各种语言的资料之间 的一致性同样需要认真的、细致的组织与安排\n\n\n\n因保持信息库的一致性，是信息库研究中的核心问题\n3.4 人机界面及其管理《用户界面程序设计–原理与实例》。这本书讨论了一系列原则\n关于用户界面的基本原则， 该书列举了以下几个方面：\n\n用户界面的主要功能是通信\n用户界面必须始终一致\n用户界面必须使用户随时掌握任务的进展状况\n用户界面必须能提供帮助\n宁可让程序多干，不可让用户多干 \n\n该书还特别讨论了在人机界面设计中经常遇到的一个困难的权衡：灵活性和一致性的矛盾\nIBM的AD/Cycle提供了应用系统及其开发过程中的一个总框架，其应用系统框架为系统应用体系结构（Systems Application Architecture——SAA）\nSAA包括三个方向的接口：程序员接口（CPI）、通信接口（CCS）、用户接口（CUA）\n人机交互的手段可归结于8个方面：键盘操作、屏幕滚动、菜单选择、帮助系统、鼠标操作、色彩应用、数据录入、信息显示\n由于技术的发展，这个归纳已经不能说是完全的了\n3.5 项目管理与版本管理项目管理项目管理是指与固定的生产线上的日常生产管理不同的，具有更大的变动性，时间性的另一类挂你任务。\n项目管理具有以下四个突出的特点：\n\n子任务多，关系复杂\n任务不可重复，形式不断变更\n协调组织**的任务十分突出，资源浪费闲置的风险与合理地优化组合、提高效益的机会并存\n信息处理工作的作用与意义更为突出\n\n进度和质量对于软件开发来说，是最关键的问题\n但是，软件开发工作还有自己的不同于一般项目管理的特点。一般工程项目没有版本更新的问题\n项目管理的基本目标：\n\n使产品(或工程)的质量得到有效的控制\n保证整个系统按预定的进度完成\n有效地利用各种资源，尽可能使资源的闲置与浪费减少\n控制与降低成本 \n\n项目管理中的方法：\n\n工程计划网络方法（计划评审技术）\n甘特图（Gantt Chart）\n检查点方法（Check Point）\n排队论等\n\n版本管理版本管理的核心是保证两个一致性。从时间上说，它的主要关心点是系统的逐步完善，以前达到的成果不要丢失\n每一步新的进步都要切实与以前的工作一致，是改进而不是破坏或降低系统的已有功能\n每一局部与整体保持一致,合理地判断每一次修改的必要性及影响范围\n版本管理的具体方法：\n\n规定长远的版本更新计划\n制定版本有关的信息范围及收集、管理方法\n在项目组内明确分工\n在程序编写、测试、文档缩写等工作中贯穿项目管理的思想及要求\n\n用户的反馈信息是项目管理与版本管理的重要资源。因此在信息库的组织、项目管理或版本管理中，都要有其对应的位置\n第4章 软件开发工具的技术要素由于软件开发工具一般都较为复杂、复杂，所以它的功能设计与总体结构是必须首先认真考虑的\n4.1 基本功能与一般结构基本功能软件开发工具的基本功能:\n\n提供描述软件状况及其开发过程的概念模式，以协助软件开发人员认识软件工作的环境与要求，合理地组织与管理软件开发的工作过程。\n提供存储和管理有关信息的机制与手段。简单地说，就是提供一个信息库和一个人机界面\n帮助使用者编制、生成及修改各种文档。（实现需信息库的支持）\n帮助使用者编写程序代码，即一般常说的代码生成\n对于历史信息进行跨生命周期的管理，把项目进度与版本更新的有关信息科学地管理**起来\n\n完整的、一体化的软件开发工具应当具备以上这些功能\n一般结构总控和人机界面处于一般结构中的中间位置，它是使用者和软件开发工具之间交流信息，实现所有的支持功能的桥梁。总控与人机界面的中心位置是不言而喻的、顺理成章的。\n系统中的另一个重要部分是信息库及其管理。信息库的结构框架反映了人们对软件产品及软件开发过程的基本看法，信息库内容的丰富程度是软件开发工具的功能与作用的最基本的依据。如果说总控和人机界面使用户面对一个良好的工作环境的话，那么在这个环境中，工作的范围及深度取决于信息库的功能和内容\n除了直接通过人机对话提供查询之外，最重要的两个信息就是代码生成与文档生成\n一般结构中没有反映出来的另一个技术要素是项目管理和版本管理\n如果要实现跨越开发周期的信息共享、知识重用以及软件重用，那么它的信息管理功能就必须大大加强\n4.2 总控与人机界面作为一个完整的、一体化的软件开发工具，总控和人机界面处于中心的位置\n解决软件配置或集成（Software Configuration）的问题的实质: 设立一个有效的总控，它能够在各个具体工具之上、实现信息的正确传递与转换，帮助人们完成协调与配合的工作，从而形成一个统一的、完整的支撑环境，并通过一个统一的、友好的人机界面与用户对话\n总控和人机界面的技术要点：面向使用者、保证信息的准确传递、保证系统的开放性（或灵活性）\nAD/Cycle是IBM根据多年软件开发的经验形成的对于软件开发过程的抽象理解，将软件开发过程的每一个周期分为五个阶段：\n\n需求分析阶段\n\n任务是建立逻辑模型\n首先建立起软件所处领域或环境的模型\n其次建立软件所要处理的信息的静态模型，即数据模型\n最后建立信息流通的模型，即信息的来源、去向、存储及处理的逻辑过程\n\n\n分析设计阶段\n\n包括数据结构的详细设计、处理过程的详细设计、子系统或模块的划分以及它们之间相互联系的具体规定\n还应当完成屏幕设计、报表设计、数据库的物理设计\n\n\n编码阶段\n\n编码阶段指具体地编写软件的阶段，这里是实际的程序代码的产生点\n\n\n测试阶段\n测试阶段指是对已经完成的各个模块或子系统进行测试、调整，以便最终形成完整的软件。这就需要准备测试数据，收集与分析测试结果\n\n维护阶段 维护阶段主要是组织管理软件的日常运行，收集运行中的状态信息及出现的问题，并及时进行局部的修改与完善 \n所谓面向用户，最根本的是要立足于符合实际的应用领域，符合软件开发人员思路的概念模型\n\n\n软件开发的技术原则:\n\n面向用户原则，具体体现在两方面：\n\n\n总控对各部分的调度与安排应当符合上述模式\n向用户提供的统一界面应当体现这个模式\n\n\n保证各部分之间信息的准确传递。信息能否准确地从一个部分传送到另一个部分，就成为一体化是否成功的关键\n\n保证系统的开放型或灵活性\n\n\n以上三项原则当然是对整个软件开发工具而言的，但是它们的实现，主要体现在总控和人机界面这个中心环节中\n4.3 信息库及其管理信息库(Repository)是软件开发工具的基础。合理地组织信息库的内容，加强信息库的管理内容，是软件开发工具的又一个重要的技术要素。\n信息库的技术要素：\n\n信息库的内容\n\n信息库的组织方式\n\n信息库的管理功能\n\n历史信息的处理方法\n\n\n1. 信息库的内容\n关于软件应用的领域与环境的状况。主要用于分析设计阶段\n\n设计成果，包括逻辑设计与物理设计的成果。主要包括数据流程图、数据字典、系统结构图、数据库的逻辑设计、各模块的设计要求，以及由此形成的设计文档。主要是为了组织实际编码工作\n\n运行状况的记录。包括 运行运行效率、作用、用户反映、故障情况、故障的原因及处理情况\n\n有关项目管理与版本管理的信息。这属于跨生命周期的信息\n\n\n2. 信息库的组织方式人们最初的思路是集中存储，集中存储的思想是建立一个庞大的数据库，把上述各种信息都存放在这个数据库中，而各种工具或实现各项单项功能的模块则围绕在这个信息库的周围，对这个信息进行录入、修改、查询、删除。这种想法比较自然，而且充分利用已有的数据库技术，比较容易保持一致性。但是，它的缺点是与前面所要求的模块化相冲突\n于是就有分散存储的想法出现，即把信息分别存入不同的数据库，由不同的功能模块来处理。这种方法的优点是易于变更和剪裁，一旦某一部分发生变更，不影响整个系统。但是各部分之间的一致性无从保证。针对这个问题，专家提出了第三种思路：逻辑上统一，物理上分散，设立统一的信息库管理模块来进行管理。它通过信息库管理模块来对分散的各个数据库进行存取，并进行一致性的检查与维护。这样一来，数据库与模块都实现了模块化，既保持了一致性，又保证了灵活性\n\n3. 信息库的管理功能图4-1中粗略地画出了三项，录入更新、使用查询、一致性维护。其中许多功能是数据库管理系统所具备的\n与一般数据库管理系统不同的有：\n\n信息之间逻辑联系的识别与记录\n如何实现定量信息与文字信息的协调一致\n\n4. 历史信息的处理方法如何处理历史信息是信息库的一个困难问题\n实际操作中出现2个具体的困难：\n\n历史信息的数量太大，占用存储设备过多\n解决方法：一般采用脱机备份的方法解决\n\n\n历史信息格式不一致，难以有效地利用\n解决方法：加强标准化，稳定数据结构\n这需要应用一些智能方法，使得跨越生命周期的信息得以相互转化、实现共享与重用\n\n\n\n4.4 文档生成与代码生成除了通过屏幕上的对话获取信息支持之外，使用者从软件开发工具得到的最主要的帮助，应当来自文档生成与代码生成两种方式\n1. 代码生成(Code Generator)代码生成器的基本任务是根据设计要求,自动地或者半自动地产生响应的某种语言的程序\n输出程序代码是这个模块的目标，输出的代码有两种情况：\n\n某种高级程序设计语言的代码\n优点：使用者可以在这基础上进一步修改加工，即利用自动生成模块作为一个原型，然后在此基础上形成自己所要求的系统（或系统的一部分）\n缺点：功能比较死，效率不高，因此还需要修改\n\n\n某种机器（包括硬件和操作系统）环境下可运行的机器指令\n优点：可以直接运行，从而立即检查是否符合要求\n\n\n\n原则：程序设计归根到底只要由人来做的，任何工具都只能发挥帮助和支持的作用，而不能完全代替人来工作\n生成代码时依据的是三个方面的资料：\n\n信息库里已有的有关资料\n代码生成器还要利用各种标准模块的框架和构件\n使用者通过屏幕前 的操作送入的信息\n\n2. 文档生成文档生成的功能与代码生成相比，数量更大，内容更复杂\n文档生成包括：文章、表格、图形\n4.5 项目管理与版本管理从技术上讲，它们的核心问题是跨生命周期的信息的管理问题。前面章节提到的历史信息的处理也是项目管理与版本管理的关键问题\n项目数据库实际上是信息库的一个组成部分。它的内容与另外几部分不同，它记录的是项目本身进展的各种信息。这里的关键是质量、进度、资源配置和费用四个基本问题\n在AD/Cycle的总框架中，对项目管理应当考虑的范围给出了如下的规定：\n\n研究与确定开发工作的方针与方法\n开发任务的划分与分工\n资源状况\n人员情况\n变更情况\n质量情况\n\n关于版本的信息，有的工具中把它作为项目数据库的一部分处理。它的主要内容是各个版本的编号、功能改变、模块组成、文档状况、推出时间、用户数量（或用户名单）、用户反映、封存情况等。\n第5章 软件开发工具的使用与开发人们首先遇到的问题往往是购买现成的软件开发工具还是自己开发专用的工具。对于这个问题，不能简单地回答是或不是，它与具体工作的条件、环境、人员素质、项目特征都有不可分割的联系\n5.1 购置与开发权衡购买市场上已有的软件开发工具，能帮助人们：\n\n减轻一定的工作负担\n使工作的组织管理比较规范\n信息的管理与检索比较方便\n\n真正经过考验的、一体化的软件开发工具还不多。他们的作用于可靠程度还不尽人意。\n自己开发的优点：\n\n目标明确，切实符合自己的需要，便于进一步扩容和升级\n不存在引进外面产品时不可避免的冲突与不一致\n\n","slug":"exam/软件开发工具","date":"2021-10-03T11:37:25.000Z","categories_index":"应试","tags_index":"升本,自考","author_index":"Jx"}]